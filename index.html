<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Invasão Espacial - Phaser</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Estilos básicos para o corpo da página */
        body {
            margin: 0;
            overflow: hidden; /* Evita barras de rolagem */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Garante que o corpo ocupe toda a altura da viewport */
            background: linear-gradient(to bottom right, #1a202c, #2d3748); /* Gradiente de fundo */
            font-family: 'Inter', sans-serif; /* Fonte moderna */
            color: #e2e8f0; /* Cor do texto */
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none; /* Safari */
            -khtml-user-select: none; /* Konqueror HTML */
            -moz-user-select: none; /* Old versions of Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
        }

        /* Estilos para o container do jogo (onde o Phaser injeta o canvas) */
        #game-container {
            position: relative; /* Necessário para o posicionamento absoluto das telas de overlay */
            width: 450px; /* Largura base do jogo */
            height: 800px; /* Altura base do jogo */
            border: 4px solid #4a5568;
            border-radius: 1.5rem;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7), 0 0 15px rgba(0, 255, 255, 0.5) inset;
            overflow: hidden; /* Garante que o conteúdo não transborde */
            display: flex; /* Para centralizar o canvas dentro dele */
            justify-content: center;
            align-items: center;
            background-color: #000; /* Fundo do jogo */
            /* Adicionado para responsividade no container */
            max-width: 98vw;
            max-height: 90vh;
        }

        /* O canvas do Phaser será dimensionado para preencher o game-container */
        canvas {
            display: block; /* Remove espaços extras */
            width: 100%; /* Preenche a largura do container */
            height: 100%; /* Preenche a altura do container */
            /* Remove estilos de borda e sombra diretamente do canvas, pois já estão no container */
            border: none;
            border-radius: 0;
            box-shadow: none;
        }

        /* Estilos para os elementos da UI sobrepostos */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Permite que os cliques passem para o canvas abaixo */
            z-index: 10; /* Acima do canvas */
        }

        .ui-element {
            position: absolute;
            padding: 0.75rem 1rem; /* Aumentado para melhor leitura */
            background-color: rgba(45, 55, 72, 0.85); /* Fundo semi-transparente mais robusto */
            border-radius: 0.75rem;
            backdrop-filter: blur(8px); /* Efeito de blur mais pronunciado */
            font-weight: bold;
            color: #e2e8f0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Posições dos elementos da UI */
        #score-damage-container { /* Novo container para pontos e dano */
            bottom: 1.5rem;
            left: 1.5rem;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.25rem;
        }
        #score-display, #damage-display {
            position: static; /* Não usa posicionamento absoluto individualmente */
            padding: 0;
            background-color: transparent;
            box-shadow: none;
            backdrop-filter: none;
            font-size: 1rem; /* Tamanho da fonte base */
            font-weight: bold;
            color: #e2e8f0;
        }
        #damage-display {
            font-size: 0.9rem; /* Dano ligeiramente menor */
        }

        #stage-display { /* Novo elemento para o estágio */
            top: 1.5rem;
            left: 1.5rem;
            font-size: 1.1rem;
        }

        #health-shield-container {
            top: 1.5rem;
            right: 1.5rem;
            flex-direction: column;
            align-items: flex-end; /* Alinha barras à direita */
            gap: 0.25rem;
        }

        #powerup-status-display {
            bottom: 7rem; /* Aumentado para evitar sobreposição */
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1rem;
            font-size: 1rem; /* Ligeiramente menor para caber melhor */
            white-space: nowrap; /* Evita quebra de linha */
        }

        /* Estilos para as barras de vida e escudo dentro da UI */
        .bar-container {
            width: 100px;
            height: 15px;
            background-color: #4a5568;
            border-radius: 0.5rem;
            overflow: hidden;
            border: 1px solid #a0aec0;
            position: relative;
        }

        .bar {
            height: 100%;
            width: 100%;
            transition: width 0.2s ease-out;
        }

        .health-bar-fill { background-color: #48bb78; }
        .shield-bar-fill { background-color: #667eea; }

        .bar-label {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 15px;
            font-size: 0.7rem;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        /* Barra de vida do Boss (visível apenas durante a boss fight) */
        #bossHealthBarContainer {
            position: absolute;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 400px; /* Largura máxima para a barra do boss */
            height: 25px;
            background-color: rgba(45, 55, 72, 0.85); /* Fundo mais robusto */
            border-radius: 0.75rem;
            border: 2px solid #e53e3e;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            display: none;
            overflow: hidden;
            z-index: 15; /* Acima de outros elementos da UI */
        }
        #bossHealthBar {
            height: 100%;
            background-color: #e53e3e;
            transition: width 0.2s ease-out;
        }
        #bossHealthLabel {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 25px;
            font-size: 1.1rem;
            color: white;
            text-shadow: 1px 1px 2px black;
        }


        /* Estilos para as telas de sobreposição (Game Over, Início, Configurações, Pausado) */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* Fundo mais opaco para telas de menu */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 1.5rem; /* Cantos arredondados do wrapper */
            text-align: center;
            font-size: 2.8rem; /* Fonte maior */
            color: #e2e8f0;
            z-index: 100;
            padding: 1rem; /* Padding para telas pequenas */
        }

        .overlay-screen h2 {
            margin-bottom: 1.5rem; /* Mais espaçamento */
            color: #fff;
            font-size: 3.5rem; /* Título maior */
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .overlay-screen p {
            font-size: 1.8rem; /* Parágrafo maior */
            margin-bottom: 2.5rem; /* Mais espaçamento */
            color: #cbd5e0;
        }

        .overlay-screen button {
            background: linear-gradient(to right, #48bb78, #38a169); /* Gradiente para botões */
            color: white;
            padding: 1rem 2rem; /* Padding maior */
            border: none;
            border-radius: 0.75rem; /* Cantos mais arredondados */
            font-size: 1.8rem; /* Fonte maior */
            cursor: pointer;
            transition: all 0.3s ease; /* Transição suave */
            margin: 0.75rem; /* Espaçamento entre botões */
            box-shadow: 0 5px 15px rgba(0, 128, 0, 0.4); /* Sombra para botões */
            pointer-events: auto; /* Permite interação com botões */
        }

        .overlay-screen button:hover {
            background: linear-gradient(to right, #38a169, #2f855a);
            transform: translateY(-3px); /* Efeito de levantar */
            box-shadow: 0 8px 20px rgba(0, 128, 0, 0.6);
        }
        .overlay-screen button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 128, 0, 0.4);
        }

        /* Estilos específicos para a tela de Game Over */
        #gameOverScreen {
            color: #fc8181; /* Vermelho claro */
            border: 3px solid #e53e3e; /* Borda vermelha */
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.9); /* Sombra mais intensa */
        }

        /* Estilos específicos para a tela de início */
        #startScreen {
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.9); /* Sombra mais intensa */
        }

        /* Estilos para a tela de configurações */
        #settingsScreen {
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.9);
            display: none; /* Escondida por padrão */
        }

        #settingsScreen .setting-option {
            display: flex;
            align-items: center;
            margin-bottom: 1.5rem; /* Mais espaçamento */
            font-size: 1.8rem; /* Fonte maior */
        }

        #settingsScreen .setting-option input[type="checkbox"] {
            margin-right: 1.5rem; /* Mais espaçamento */
            width: 30px; /* Checkbox maior */
            height: 30px;
            cursor: pointer;
            accent-color: #48bb78; /* Cor do checkbox */
        }

        /* Botão de Pausar para Mobile */
        #pauseButton {
            position: absolute;
            bottom: 1.5rem;
            right: 1.5rem;
            background: linear-gradient(to right, #667eea, #5a67d8); /* Gradiente azul */
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(102, 118, 234, 0.4);
            pointer-events: auto; /* Permite interação */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px; /* Tamanho fixo para o botão */
            height: 60px;
        }
        #pauseButton:hover {
            background: linear-gradient(to right, #5a67d8, #4c51bf);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(102, 118, 234, 0.6);
        }
        #pauseButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(102, 118, 234, 0.4);
        }

        /* Tela de Pausa */
        #pauseScreen {
            display: none; /* Escondida por padrão */
        }

        /* Responsividade para telas menores */
        @media (max-width: 768px) {
            #game-container {
                width: 100vw; /* Ocupa a largura total da viewport */
                height: 100vh; /* Ocupa a altura total da viewport */
                max-width: 100vw; /* Garante que ocupe o máximo possível */
                max-height: 100vh; /* Garante que ocupe o máximo possível */
                border-radius: 0; /* Remove bordas arredondadas em tela cheia */
                box-shadow: none; /* Remove sombra em tela cheia */
            }
            .overlay-screen {
                border-radius: 0; /* Remove bordas arredondadas nas telas de overlay em tela cheia */
            }
            /* Make UI elements responsive */
            .ui-element {
                padding: 1.5vmin 2vmin; /* Responsive padding */
                font-size: 2.5vmin; /* Responsive font size */
                border-radius: 1vmin; /* Responsive border-radius */
            }
            #score-damage-container {
                bottom: 2%; /* Percentage-based positioning */
                left: 2%;
            }
            #score-display, #damage-display {
                font-size: 2.2vmin; /* Slightly smaller responsive font size */
            }
            #stage-display {
                top: 2%;
                left: 2%;
                font-size: 2.5vmin;
            }
            #health-shield-container {
                top: 2%;
                right: 2%;
            }
            #powerup-status-display {
                bottom: 12%; /* Adjusted to be further from bottom */
                font-size: 2.2vmin;
            }
            .bar-container {
                width: 20vmin; /* Responsive width */
                height: 3vmin; /* Responsive height */
                border-radius: 0.75vmin; /* Responsive border-radius */
            }
            .bar-label {
                font-size: 1.8vmin; /* Responsive font size */
                line-height: 3vmin; /* Match bar height */
            }
            #bossHealthBarContainer {
                max-width: 90vw; /* Max width relative to viewport */
                height: 4vmin; /* Responsive height */
                border-radius: 1vmin;
            }
            #bossHealthLabel {
                font-size: 3vmin; /* Responsive font size */
                line-height: 4vmin; /* Match bar height */
            }
            .overlay-screen h2 {
                font-size: 5vmin; /* Responsive title size */
            }
            .overlay-screen p {
                font-size: 3vmin; /* Responsive paragraph size */
            }
            .overlay-screen button {
                padding: 2vmin 4vmin; /* Responsive padding */
                font-size: 3vmin; /* Responsive font size */
                margin: 1vmin; /* Responsive margin */
                border-radius: 1.5vmin; /* Responsive border-radius */
            }
            #settingsScreen .setting-option {
                font-size: 3vmin;
            }
            #settingsScreen .setting-option input[type="checkbox"] {
                width: 5vmin;
                height: 5vmin;
                margin-right: 2vmin;
            }
            #pauseButton {
                width: 10vmin; /* Responsive width */
                height: 10vmin; /* Responsive height */
                font-size: 4vmin; /* Responsive font size for icon */
                bottom: 2%;
                right: 2%;
                border-radius: 50%; /* Make it a circle */
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <canvas id="gameCanvas" width="450" height="800"></canvas>

        <div class="ui-overlay">
            <!-- Pontos e Dano -->
            <div id="score-damage-container" class="ui-element">
                <div id="score-display">
                    <span>Pontos: <span id="score">0</span></span>
                </div>
                <div id="damage-display">
                    <span>Dano: <span id="playerDamage">1</span></span>
                </div>
            </div>

            <!-- Estágio -->
            <div id="stage-display" class="ui-element">
                <span>Estágio: <span id="currentStageDisplay">1</span></span>
            </div>

            <!-- Vida e Escudo -->
            <div id="health-shield-container" class="ui-element">
                <div class="bar-container">
                    <div id="healthBar" class="bar health-bar-fill"></div>
                    <span class="bar-label">Vida: <span id="health">100</span></span>
                </div>
                <div class="bar-container">
                    <div id="shieldBar" class="bar shield-bar-fill"></div>
                    <span class="bar-label">Escudo: <span id="shield">0</span></span>
                </div>
            </div>

            <!-- Status de Power-up -->
            <div id="powerup-status-display" class="ui-element">
                <span>Power-up: <span id="powerup-status">Nenhum</span></span>
            </div>

            <!-- Barra de vida do Boss (visível apenas durante a boss fight) -->
            <div id="bossHealthBarContainer">
                <div id="bossHealthBar" class="boss-health-bar"></div>
                <span id="bossHealthLabel">BOSS: <span id="bossHealth"></span></span>
            </div>

            <!-- Botão de Pausar (apenas para mobile) -->
            <button id="pauseButton" style="display: none;">
                <!-- Ícone de pausa SVG -->
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-8 h-8">
                    <path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>


        <!-- Tela de Início do Jogo -->
        <div id="startScreen" class="overlay-screen">
            <h2>Invasão Espacial</h2>
            <p>Mova a nave arrastando o dedo na tela para se desviar e atirar!</p>
            <div>
                <button id="startButton">Iniciar Jogo</button>
                <button id="settingsButton">Configurações</button>
            </div>
        </div>

        <!-- Tela de Configurações -->
        <div id="settingsScreen" class="overlay-screen">
            <h2>Configurações</h2>
            <div class="setting-option">
                <input type="checkbox" id="toggleShotSounds" checked>
                <label for="toggleShotSounds">Sons de Tiro</label>
            </div>
            <div class="setting-option">
                <input type="checkbox" id="toggleBackgroundMusic" checked>
                <label for="toggleBackgroundMusic">Música de Fundo</label>
            </div>
            <button id="backToStartButton">Voltar</button>
        </div>

        <!-- Tela de Pausa -->
        <div id="pauseScreen" class="overlay-screen" style="display: none;">
            <h2>Jogo Pausado</h2>
            <p>Pressione Espaço/Esc ou o botão de Pausa para continuar.</p>
            <button id="resumeButton">Continuar Jogo</button>
        </div>

        <!-- Tela de Game Over -->
        <div id="gameOverScreen" class="overlay-screen" style="display: none;">
            <h2>Fim de Jogo!</h2>
            <p>Sua pontuação final: <span id="finalScore">0</span></p>
            <button id="restartButton">Jogar Novamente</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script>
        // Obtenha o canvas e o contexto 2D
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Elementos da UI
        const scoreDisplay = document.getElementById('score');
        const playerDamageDisplay = document.getElementById('playerDamage'); // Novo elemento para dano do jogador
        const healthDisplay = document.getElementById('health');
        const healthBar = document.getElementById('healthBar');
        const shieldDisplay = document.getElementById('shield');
        const shieldBar = document.getElementById('shieldBar');
        const powerupStatusDisplay = document.getElementById('powerup-status');
        const bossHealthBarContainer = document.getElementById('bossHealthBarContainer');
        const bossHealthBar = document.getElementById('bossHealthBar');
        const bossHealthDisplay = document.getElementById('bossHealth');
        const currentStageDisplay = document.getElementById('currentStageDisplay'); // Novo elemento para estágio

        // Telas de sobreposição
        const startScreen = document.getElementById('startScreen');
        const settingsScreen = document.getElementById('settingsScreen');
        const pauseScreen = document.getElementById('pauseScreen'); // Nova tela de pausa
        const gameOverScreen = document.getElementById('gameOverScreen');

        // Botões
        const startButton = document.getElementById('startButton');
        const settingsButton = document.getElementById('settingsButton');
        const backToStartButton = document.getElementById('backToStartButton');
        const toggleShotSounds = document.getElementById('toggleShotSounds');
        const toggleBackgroundMusic = document.getElementById('toggleBackgroundMusic');
        const pauseButton = document.getElementById('pauseButton'); // Novo botão de pausa
        const resumeButton = document.getElementById('resumeButton'); // Novo botão de continuar
        const restartButton = document.getElementById('restartButton');

        // Variáveis do jogo
        let player;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let powerUps = [];
        let particles = [];
        let score = 0;
        let gameRunning = false;
        let isPaused = false; // Estado de pausa do jogo
        let activePowerUps = {}; // Armazena power-ups ativos e seus timers
        let spawnEnemyInterval;
        let enemySpeedMultiplier = 1;
        let stars = [];
        let currentEnemyLevel = 1;
        let bossActive = false;
        let boss = null;
        let backgroundMusic;
        let currentStage = 1;

        // Configurações do jogo
        const gameSettings = {
            shotSoundsEnabled: true,
            backgroundMusicEnabled: true
        };

        // Detecção de dispositivo (mobile vs. desktop)
        const isMobile = () => {
            return ('ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0);
        };

        const NUM_STARS = 200;
        const STAR_SPEED = 0.5;

        // Constantes do jogo
        const PLAYER_INITIAL_WIDTH = 60;
        const PLAYER_INITIAL_HEIGHT = 60;
        const PLAYER_BULLET_SPEED = 7;
        const PLAYER_BASE_BULLET_DAMAGE = 1;
        const ENEMY_BASE_SPEED = 1;
        const ENEMY_BASE_DAMAGE = 10;
        const ENEMY_BULLET_SPEED = 3;
        const ENEMY_SPAWN_INTERVAL = 1500;
        const PLAYER_FIRE_RATE = 200;
        const ENEMY_FIRE_RATE = 1500;
        const POWER_UP_DURATION = 7000;
        const MAX_SHIELD = 100;
        const POWER_UP_DROP_CHANCE = 0.10;

        const SCORE_PER_ENEMY_LEVEL_UP = 30;
        const ENEMY_HEALTH_PER_LEVEL = 1;
        const ENEMY_STRENGTH_INCREASE_PER_LEVEL = 0.1;

        const BOSS_SCORE_THRESHOLD = 100;
        const BOSS_HEALTH_MULTIPLIER = 10;
        const BOSS_DAMAGE_MULTIPLIER = 1.5;
        const BOSS_SPEED_MULTIPLIER = 0.8;
        const BOSS_ENTRY_SPEED = 2;

        const ENEMY_COLLISION_DAMAGE = 20;
        const BOSS_COLLISION_DAMAGE = 30;

        const STAGE_DIFFICULTY_INCREASE = 0.20;

        const BOSS_RAGE_THRESHOLD = 0.35;
        const BOSS_RAGE_FIRE_RATE_MULTIPLIER = 0.7;
        const BOSS_RAGE_DAMAGE_MULTIPLIER = 1.3;
        const BOSS_RAGE_SPEED_MULTIPLIER = 1.3;

        const ENEMY_COLORS = [
            '#FF0000', '#FF4500', '#FF8C00', '#FFD700', '#ADFF2F',
            '#00FF00', '#00FFFF', '#00BFFF', '#8A2BE2', '#FF00FF',
        ];

        // Sons
        let playerShootSound, enemyShootSound, hitSound, powerUpSound,
            gameOverSound, bossHitSound, bossDefeatSound, explosionSound;

        function initSounds() {
            playerShootSound = new Tone.Synth().toDestination(); playerShootSound.envelope.release = 0.05;
            enemyShootSound = new Tone.Synth({ oscillator: { type: "square" }, envelope: { release: 0.1 } }).toDestination();
            hitSound = new Tone.NoiseSynth({ envelope: { release: 0.1 } }).toDestination();
            powerUpSound = new Tone.PolySynth(Tone.Synth).toDestination();
            gameOverSound = new Tone.Synth().toDestination();
            bossHitSound = new Tone.NoiseSynth({ envelope: { release: 0.2, decay: 0.1 } }).toDestination();
            bossDefeatSound = new Tone.PolySynth(Tone.Synth).toDestination();
            explosionSound = new Tone.NoiseSynth({ envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.3 } }).toDestination();

            backgroundMusic = new Tone.Loop(time => {
                const synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.5, decay: 0.5, sustain: 0.8, release: 1 }
                }).toDestination();
                synth.triggerAttackRelease(["C3", "E3", "G3", "B3"], "2n", time);
            }, "4m");
        }

        function playPlayerShootSound() { if (Tone.context.state === 'running' && gameSettings.shotSoundsEnabled) playerShootSound.triggerAttackRelease("C5", "8n"); }
        function playEnemyShootSound() { if (Tone.context.state === 'running' && gameSettings.shotSoundsEnabled) enemyShootSound.triggerAttackRelease("C3", "8n"); }
        function playHitSound() { if (Tone.context.state === 'running' && gameSettings.shotSoundsEnabled) hitSound.triggerAttackRelease("16n"); }
        function playPowerUpSound() { if (Tone.context.state === 'running' && gameSettings.shotSoundsEnabled) powerUpSound.triggerAttackRelease("C4", "8n"); }
        function playGameOverSound() { if (Tone.context.state === 'running' && gameSettings.shotSoundsEnabled) { gameOverSound.triggerAttackRelease("C3", "4n"); gameOverSound.triggerAttackRelease("G2", "4n", "+0.5"); } }
        function playBossHitSound() { if (Tone.context.state === 'running' && gameSettings.shotSoundsEnabled) bossHitSound.triggerAttackRelease("8n"); }
        function playBossDefeatSound() { if (Tone.context.state === 'running' && gameSettings.shotSoundsEnabled) bossDefeatSound.triggerAttackRelease(["C4", "F4", "A4", "C5"], "2n"); }
        function playExplosionSound() { if (Tone.context.state === 'running' && gameSettings.shotSoundsEnabled) explosionSound.triggerAttackRelease("16n"); }

        class GameObject {
            constructor(x, y, width, height, color) {
                this.x = x; this.y = y; this.width = width; this.height = height; this.color = color;
            }
            draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }

        class Particle extends GameObject {
            constructor(x, y, size, color, speedX, speedY, life) {
                super(x, y, size, size, color);
                this.speedX = speedX; this.speedY = speedY; this.life = life; this.maxLife = life;
            }
            update() {
                this.x += this.speedX; this.y += this.speedY; this.life--;
                this.opacity = this.life / this.maxLife;
            }
            draw() {
                ctx.save(); ctx.globalAlpha = this.opacity; ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height); ctx.restore();
            }
        }

        class Player extends GameObject {
            constructor(x, y) {
                super(x, y, PLAYER_INITIAL_WIDTH, PLAYER_INITIAL_HEIGHT, '#00FFFF');
                this.health = 100; this.shield = 0; this.lastShotTime = 0;
                this.fireRate = PLAYER_FIRE_RATE; this.bulletDamage = PLAYER_BASE_BULLET_DAMAGE;
                this.rapidFireActive = false; this.shieldActive = false;
            }
            draw() {
                ctx.fillStyle = this.color; ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#ADD8E6'; ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 3, this.width / 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#00BFFF';
                ctx.fillRect(this.x - 5, this.y + this.height / 2, 5, this.height / 2);
                ctx.fillRect(this.x + this.width, this.y + this.height / 2, 5, this.height / 2);
            }
            shoot() {
                const currentTime = Date.now();
                const actualFireRate = this.rapidFireActive ? PLAYER_FIRE_RATE / 2 : PLAYER_FIRE_RATE;
                if (currentTime - this.lastShotTime > actualFireRate) {
                    bullets.push(new Bullet(this.x + this.width / 2 - 2, this.y, 4, 10, '#FFFF00', -PLAYER_BULLET_SPEED, this.bulletDamage));
                    this.lastShotTime = currentTime; playPlayerShootSound();
                }
            }
            takeDamage(amount) {
                let remainingDamage = amount;
                if (this.shield > 0) {
                    const damageToShield = Math.min(remainingDamage, this.shield);
                    this.shield -= damageToShield; remainingDamage -= damageToShield;
                    this.updateShieldDisplay();
                }
                if (remainingDamage > 0) {
                    this.health -= remainingDamage; if (this.health < 0) this.health = 0;
                    this.updateHealthDisplay();
                }
                playHitSound();
            }
            activateShieldPowerUp(duration) {
                this.shield = MAX_SHIELD; this.shieldActive = true; this.updateShieldDisplay();
                if (activePowerUps.shieldTimer) clearTimeout(activePowerUps.shieldTimer);
                activePowerUps.shieldTimer = setTimeout(() => {
                    this.shield = 0; this.shieldActive = false; this.updateShieldDisplay(); this.updatePowerUpStatusDisplay();
                }, duration);
                this.updatePowerUpStatusDisplay();
            }
            activateRapidFire(duration) {
                this.rapidFireActive = true;
                if (activePowerUps.rapidFireTimer) clearTimeout(activePowerUps.rapidFireTimer);
                activePowerUps.rapidFireTimer = setTimeout(() => {
                    this.rapidFireActive = false; this.updatePowerUpStatusDisplay();
                }, duration);
                this.updatePowerUpStatusDisplay();
            }
            increaseDamage(amount) {
                this.bulletDamage += amount; this.updatePowerUpStatusDisplay();
            }
            updateHealthDisplay() {
                healthDisplay.textContent = this.health; healthBar.style.width = `${this.health}%`;
                healthBar.style.backgroundColor = this.health <= 20 ? '#e53e3e' : '#48bb78';
            }
            updateShieldDisplay() {
                shieldDisplay.textContent = this.shield; shieldBar.style.width = `${(this.shield / MAX_SHIELD) * 100}%`;
            }
            updatePowerUpStatusDisplay() {
                let statusText = [];
                if (this.rapidFireActive) statusText.push('Tiro Rápido');
                if (this.shieldActive) statusText.push('Escudo');
                if (this.bulletDamage > PLAYER_BASE_BULLET_DAMAGE) statusText.push(`Dano +${this.bulletDamage - PLAYER_BASE_BULLET_DAMAGE}`);
                powerupStatusDisplay.textContent = statusText.length === 0 ? 'Nenhum' : statusText.join(', ');
                playerDamageDisplay.textContent = this.bulletDamage; // Atualiza o display de dano
            }
        }

        class Bullet extends GameObject {
            constructor(x, y, width, height, color, speedY, damage = 1) {
                super(x, y, width, height, color); this.speedY = speedY; this.damage = damage;
            }
            update() { this.y += this.speedY; }
        }

        class Enemy extends GameObject {
            constructor(x, y, level, stage) {
                const enemyColor = ENEMY_COLORS[Math.min(level - 1, ENEMY_COLORS.length - 1)];
                super(x, y, 50, 50, enemyColor);
                this.lastShotTime = 0; this.fireRate = ENEMY_FIRE_RATE + Math.random() * 1000;
                this.level = level;
                this.maxHealth = ENEMY_HEALTH_PER_LEVEL * this.level * (1 + (stage - 1) * STAGE_DIFFICULTY_INCREASE);
                this.health = this.maxHealth;
                this.damage = ENEMY_BASE_DAMAGE * (1 + (this.level - 1) * ENEMY_STRENGTH_INCREASE_PER_LEVEL) * (1 + (stage - 1) * STAGE_DIFFICULTY_INCREASE);
            }
            draw() {
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#8B0000'; ctx.fillRect(this.x + this.width * 0.2, this.y + this.height * 0.2, this.width * 0.6, this.height * 0.6);
                ctx.fillStyle = '#FF4500';
                ctx.fillRect(this.x - 10, this.y + this.height / 4, 10, this.height / 2);
                ctx.fillRect(this.x + this.width, this.y + this.height / 4, 10, this.height / 2);

                const healthBarWidth = 40; const healthBarHeight = 5;
                const healthPercentage = this.health / this.maxHealth;
                ctx.fillStyle = '#4a5568';
                ctx.fillRect(this.x + (this.width - healthBarWidth) / 2, this.y - healthBarHeight - 5, healthBarWidth, healthBarHeight);
                ctx.fillStyle = healthPercentage > 0.5 ? '#48bb78' : (healthPercentage > 0.2 ? '#FFD700' : '#e53e3e');
                ctx.fillRect(this.x + (this.width - healthBarWidth) / 2, this.y - healthBarHeight - 5, healthBarWidth * healthPercentage, healthBarHeight);
            }
            update() { this.y += ENEMY_BASE_SPEED * enemySpeedMultiplier; }
            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime > this.fireRate) {
                    enemyBullets.push(new Bullet(this.x + this.width / 2 - 2, this.y + this.height, 4, 10, '#00FF00', ENEMY_BULLET_SPEED, this.damage));
                    this.lastShotTime = currentTime; playEnemyShootSound();
                }
            }
            takeDamage(amount) {
                this.health -= amount; playHitSound();
                for (let i = 0; i < 5; i++) particles.push(new Particle(this.x + this.width / 2, this.y + this.height / 2, 3, '#FFFF00', (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, 20));
                return this.health <= 0;
            }
        }

        class Boss extends GameObject {
            constructor(x, y, level, stage) {
                super(x, y, 150, 150, '#FF4500');
                this.lastShotTime = 0; this.fireRate = ENEMY_FIRE_RATE / 2;
                this.level = level;
                this.maxHealth = (ENEMY_HEALTH_PER_LEVEL * this.level) * BOSS_HEALTH_MULTIPLIER * (1 + (stage - 1) * STAGE_DIFFICULTY_INCREASE);
                this.health = this.maxHealth;
                this.damage = (ENEMY_BASE_DAMAGE * (1 + (this.level - 1) * ENEMY_STRENGTH_INCREASE_PER_LEVEL)) * BOSS_DAMAGE_MULTIPLIER * (1 + (stage - 1) * STAGE_DIFFICULTY_INCREASE);
                this.speedX = 2; this.state = 'entering'; this.isRaging = false;
                this.attackPattern = 0; this.lastAttackChangeTime = 0; this.attackChangeInterval = 2000;
            }
            draw() {
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#8B0000'; ctx.fillRect(this.x + this.width * 0.1, this.y + this.height * 0.1, this.width * 0.8, this.height * 0.8);
                ctx.fillStyle = '#FFD700'; ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 4, 0, Math.PI * 2);
                ctx.fill();
                if (this.isRaging) { ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 5; ctx.strokeRect(this.x, this.y, this.width, this.height); }
            }
            update() {
                if (!this.isRaging && this.health / this.maxHealth <= BOSS_RAGE_THRESHOLD) {
                    this.isRaging = true; this.fireRate *= BOSS_RAGE_FIRE_RATE_MULTIPLIER;
                    this.damage *= BOSS_RAGE_DAMAGE_MULTIPLIER; this.speedX *= BOSS_RAGE_SPEED_MULTIPLIER;
                    this.color = '#B22222';
                }
                if (this.state === 'entering') {
                    this.y += BOSS_ENTRY_SPEED;
                    if (this.y >= 50) { this.y = 50; this.state = 'fighting'; }
                } else if (this.state === 'fighting') {
                    this.x += this.speedX;
                    if (this.x + this.width > canvas.width || this.x < 0) { this.speedX *= -1; }
                }
            }
            shoot() {
                if (this.state !== 'fighting') return;
                const currentTime = Date.now();
                if (currentTime - this.lastAttackChangeTime > this.attackChangeInterval) {
                    this.attackPattern = (this.attackPattern + 1) % 3; this.lastAttackChangeTime = currentTime;
                }
                if (currentTime - this.lastShotTime > this.fireRate) {
                    const bulletDamage = this.damage;
                    switch (this.attackPattern) {
                        case 0: // Double Shot
                            enemyBullets.push(new Bullet(this.x + this.width * 0.25, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED, bulletDamage));
                            enemyBullets.push(new Bullet(this.x + this.width * 0.75, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED, bulletDamage));
                            break;
                        case 1: // Triple Shot
                            enemyBullets.push(new Bullet(this.x + this.width * 0.2, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED, bulletDamage));
                            enemyBullets.push(new Bullet(this.x + this.width * 0.5, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED, bulletDamage));
                            enemyBullets.push(new Bullet(this.x + this.width * 0.8, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED, bulletDamage));
                            break;
                        case 2: // Fan Shot
                            enemyBullets.push(new Bullet(this.x + this.width * 0.2, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED, bulletDamage));
                            enemyBullets.push(new Bullet(this.x + this.width * 0.5, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED * 0.8, bulletDamage));
                            enemyBullets.push(new Bullet(this.x + this.width * 0.8, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED, bulletDamage));
                            enemyBullets.push(new Bullet(this.x + this.width * 0.1, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED * 1.2, bulletDamage));
                            enemyBullets.push(new Bullet(this.x + this.width * 0.9, this.y + this.height, 4, 10, '#FF00FF', ENEMY_BULLET_SPEED * 1.2, bulletDamage));
                            break;
                    }
                    this.lastShotTime = currentTime; playEnemyShootSound();
                }
            }
            takeDamage(amount) {
                this.health -= amount; playBossHitSound();
                for (let i = 0; i < 10; i++) particles.push(new Particle(this.x + this.width / 2, this.y + this.height / 2, Math.random() * 8 + 2, `hsl(${Math.random() * 60}, 100%, 50%)`, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, 30));
                this.updateBossHealthDisplay(); return this.health <= 0;
            }
            updateBossHealthDisplay() {
                bossHealthDisplay.textContent = `${Math.max(0, Math.floor(this.health))} / ${Math.floor(this.maxHealth)}`;
                bossHealthBar.style.width = `${(this.health / this.maxHealth) * 100}%`;
            }
        }

        class PowerUp extends GameObject {
            constructor(x, y, type) {
                let color, symbol;
                if (type === 'rapidFire') { color = '#FFD700'; symbol = '⚡'; }
                else if (type === 'shield') { color = '#8A2BE2'; symbol = '🛡️'; }
                else if (type === 'damageUp') { color = '#FF6347'; symbol = '+1'; }
                super(x, y, 25, 25, color); this.type = type; this.symbol = symbol;
            }
            draw() {
                ctx.fillStyle = this.color;
                if (this.type === 'rapidFire') {
                    ctx.beginPath(); const outerRadius = this.width / 2; const innerRadius = outerRadius / 2.5; const numPoints = 5;
                    for (let i = 0; i < numPoints * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (Math.PI / numPoints) * i;
                        const px = this.x + this.width / 2 + radius * Math.sin(angle);
                        const py = this.y + this.height / 2 - radius * Math.cos(angle);
                        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                    }
                    ctx.closePath(); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#FFFFFF'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x + this.width / 2, this.y + this.height / 2 + 2);
            }
            update() { this.y += (ENEMY_BASE_SPEED / 2) * enemySpeedMultiplier; }
        }

        function checkCollision(obj1, obj2) {
            if (!obj1 || !obj2) return false;
            return obj1.x < obj2.x + obj2.width && obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height && obj1.y + obj1.height > obj2.y;
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseScreen.style.display = 'flex';
                clearInterval(spawnEnemyInterval);
                Tone.Transport.pause(); // Pausa o transporte do Tone.js
            } else {
                pauseScreen.style.display = 'none';
                // Só reinicia o spawn de inimigos se não estiver em boss fight
                if (!bossActive) {
                    spawnEnemyInterval = setInterval(spawnEnemy, ENEMY_SPAWN_INTERVAL);
                }
                if (gameSettings.backgroundMusicEnabled) {
                    Tone.Transport.start(); // Retoma o transporte
                }
                gameLoop(); // Retoma o loop do jogo
            }
        }

        function startGame() {
            startScreen.style.display = 'none'; gameOverScreen.style.display = 'none';
            settingsScreen.style.display = 'none'; pauseScreen.style.display = 'none';

            if (Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    console.log('Audio context started');
                    initGameLogic();
                    if (gameSettings.backgroundMusicEnabled) {
                        backgroundMusic.start(0); Tone.Transport.start();
                    }
                }).catch(e => console.error("Erro ao iniciar o contexto de áudio:", e));
            } else {
                initGameLogic();
                if (gameSettings.backgroundMusicEnabled) {
                    backgroundMusic.start(0); Tone.Transport.start();
                }
            }
            // Mostra o botão de pausa apenas em mobile
            if (isMobile()) {
                pauseButton.style.display = 'flex';
            } else {
                pauseButton.style.display = 'none';
            }
        }

        function initGameLogic() {
            if (!playerShootSound) initSounds();

            player = new Player(canvas.width / 2 - PLAYER_INITIAL_WIDTH / 2, canvas.height / 2 - PLAYER_INITIAL_HEIGHT / 2);

            bullets = []; enemies = []; enemyBullets = []; powerUps = []; particles = [];
            initStars();

            if (currentStage === 1) {
                score = 0; player.health = 100; player.shield = 0; player.bulletDamage = PLAYER_BASE_BULLET_DAMAGE;
            }
            player.updateHealthDisplay(); player.updateShieldDisplay(); player.updatePowerUpStatusDisplay();
            scoreDisplay.textContent = score;
            currentStageDisplay.textContent = currentStage; // Atualiza o display do estágio

            activePowerUps = {}; player.rapidFireActive = false; player.shieldActive = false;
            player.fireRate = PLAYER_FIRE_RATE;

            enemySpeedMultiplier = 1; currentEnemyLevel = 1;

            bossActive = false; boss = null; bossHealthBarContainer.style.display = 'none';

            gameRunning = true; isPaused = false;

            if (!bossActive) spawnEnemyInterval = setInterval(spawnEnemy, ENEMY_SPAWN_INTERVAL);

            // Garante que o loop de animação seja iniciado apenas uma vez
            if (!animationFrameId) {
                gameLoop();
            }
        }

        function spawnEnemy() {
            if (!gameRunning || bossActive || isPaused) return;
            const x = Math.random() * (canvas.width - 50);
            enemies.push(new Enemy(x, -50, currentEnemyLevel, currentStage));
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < NUM_STARS; i++) {
                stars.push({
                    x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1, opacity: Math.random() * 0.5 + 0.5
                });
            }
        }

        function startBossFight() {
            bossActive = true; clearInterval(spawnEnemyInterval);
            enemies = []; enemyBullets = []; powerUps = []; particles = [];

            boss = new Boss(canvas.width / 2 - 75, -200, currentEnemyLevel, currentStage);
            bossHealthBarContainer.style.display = 'block'; boss.updateBossHealthDisplay();
        }

        function update() {
            if (!gameRunning || isPaused) return;

            if (score > 0 && score % BOSS_SCORE_THRESHOLD === 0 && !bossActive && boss === null) {
                startBossFight();
            }

            currentEnemyLevel = Math.floor(score / SCORE_PER_ENEMY_LEVEL_UP) + 1;
            enemySpeedMultiplier = 1 + (currentEnemyLevel - 1) * ENEMY_STRENGTH_INCREASE_PER_LEVEL;
            if (enemySpeedMultiplier > 5) enemySpeedMultiplier = 5;

            stars.forEach(star => {
                star.y += STAR_SPEED;
                if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; }
            });

            player.shoot();

            for (let i = bullets.length - 1; i >= 0; i--) {
                if (!bullets[i]) continue; bullets[i].update();
                if (bullets[i].y < 0) bullets.splice(i, 1);
            }

            if (bossActive && boss) {
                boss.update(); boss.shoot();

                for (let i = bullets.length - 1; i >= 0; i--) {
                    if (!bullets[i]) continue;
                    if (checkCollision(bullets[i], boss)) {
                        if (boss.takeDamage(bullets[i].damage)) {
                            playBossDefeatSound(); playExplosionSound();
                            for (let p = 0; p < 50; p++) particles.push(new Particle(boss.x + boss.width / 2, boss.y + boss.height / 2, Math.random() * 8 + 2, `hsl(${Math.random() * 60}, 100%, 50%)`, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, 60));
                            score += 100; scoreDisplay.textContent = score; currentStage++;
                            currentStageDisplay.textContent = currentStage; // Atualiza o display do estágio
                            
                            // Lógica de progressão de chefe: 40% a mais de pontos para o próximo chefe
                            BOSS_SCORE_THRESHOLD = Math.floor(BOSS_SCORE_THRESHOLD * 1.4);
                            console.log(`Próximo chefe em Estágio ${currentStage}. Limite de pontuação: ${BOSS_SCORE_THRESHOLD}`);

                            // Reinicia o spawn de inimigos normais
                            spawnEnemyInterval = setInterval(spawnEnemy, ENEMY_SPAWN_INTERVAL);
                            bossActive = false; // Desativa o modo boss
                            boss = null; // Limpa a referência do boss
                            bossHealthBarContainer.style.display = 'none'; // Esconde a barra de vida do boss
                            enemyBullets = []; // Limpa os tiros do boss
                            
                            // Não reinicia o jogo completo, apenas o estado para o próximo estágio
                            // O player, score, etc. persistem.
                            return; // Sai da função update para evitar processamento adicional
                        }
                        bullets.splice(i, 1);
                    }
                }
                if (checkCollision(player, boss)) {
                    player.takeDamage(BOSS_COLLISION_DAMAGE);
                    if (player.health <= 0) {
                        playExplosionSound();
                        for (let p = 0; p < 30; p++) particles.push(new Particle(player.x + player.width / 2, player.y + player.height / 2, Math.random() * 5 + 1, `hsl(${Math.random() * 360}, 100%, 50%)`, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, 40));
                        endGame(); return;
                    }
                }
            } else {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (!enemies[i]) continue; enemies[i].update(); enemies[i].shoot();
                    if (enemies[i].y > canvas.height) enemies.splice(i, 1);
                    if (checkCollision(player, enemies[i])) {
                        player.takeDamage(ENEMY_COLLISION_DAMAGE); playExplosionSound();
                        for (let p = 0; p < 20; p++) particles.push(new Particle(enemies[i].x + enemies[i].width / 2, enemies[i].y + enemies[i].height / 2, Math.random() * 4 + 1, `hsl(${Math.random() * 60}, 100%, 50%)`, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, 30));
                        enemies.splice(i, 1);
                        if (player.health <= 0) {
                            playExplosionSound();
                            for (let p = 0; p < 30; p++) particles.push(new Particle(player.x + player.width / 2, player.y + player.height / 2, Math.random() * 5 + 1, `hsl(${Math.random() * 360}, 100%, 50%)`, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, 40));
                            endGame(); return;
                        }
                    }
                }
                for (let i = bullets.length - 1; i >= 0; i--) {
                    if (!bullets[i]) continue;
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (!enemies[j]) continue;
                        if (checkCollision(bullets[i], enemies[j])) {
                            if (enemies[j].takeDamage(bullets[i].damage)) {
                                score += 1; scoreDisplay.textContent = score; playExplosionSound();
                                for (let p = 0; p < 20; p++) particles.push(new Particle(enemies[j].x + enemies[j].width / 2, enemies[j].y + enemies[j].height / 2, Math.random() * 4 + 1, `hsl(${Math.random() * 60}, 100%, 50%)`, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, 30));
                                if (Math.random() < POWER_UP_DROP_CHANCE) {
                                    const rand = Math.random(); let type;
                                    if (rand < 0.33) type = 'rapidFire';
                                    else if (rand < 0.66) type = 'shield';
                                    else type = 'damageUp';
                                    powerUps.push(new PowerUp(enemies[j].x + enemies[j].width / 2 - 12, enemies[j].y + enemies[j].height / 2 - 12, type));
                                }
                                enemies.splice(j, 1);
                            }
                            bullets.splice(i, 1); break;
                        }
                    }
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                if (!enemyBullets[i]) continue; enemyBullets[i].update();
                if (enemyBullets[i].y > canvas.height) enemyBullets.splice(i, 1);
                if (checkCollision(player, enemyBullets[i])) {
                    player.takeDamage(enemyBullets[i].damage); enemyBullets.splice(i, 1);
                    if (player.health <= 0) {
                        playExplosionSound();
                        for (let p = 0; p < 30; p++) particles.push(new Particle(player.x + player.width / 2, player.y + player.height / 2, Math.random() * 5 + 1, `hsl(${Math.random() * 360}, 100%, 50%)`, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, 40));
                        endGame(); return;
                    }
                }
            }

            for (let i = powerUps.length - 1; i >= 0; i--) {
                if (!powerUps[i]) continue; powerUps[i].update();
                if (powerUps[i].y > canvas.height) powerUps.splice(i, 1);
                if (checkCollision(player, powerUps[i])) {
                    playPowerUpSound();
                    if (powerUps[i].type === 'rapidFire') player.activateRapidFire(POWER_UP_DURATION);
                    else if (powerUps[i].type === 'shield') player.activateShieldPowerUp(POWER_UP_DURATION);
                    else if (powerUps[i].type === 'damageUp') player.increaseDamage(1);
                    powerUps.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i]) continue; particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0a2a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            });

            player.draw();
            bullets.forEach(bullet => bullet.draw());
            if (bossActive && boss) boss.draw(); else enemies.forEach(enemy => enemy.draw());
            enemyBullets.forEach(bullet => bullet.draw());
            powerUps.forEach(powerUp => powerUp.draw());
            particles.forEach(particle => particle.draw());
        }

        let animationFrameId; // Variável para armazenar o ID do frame de animação

        function gameLoop() {
            if (!gameRunning || isPaused) {
                // Se o jogo não estiver rodando ou estiver pausado, não chame requestAnimationFrame
                return;
            }
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            clearInterval(spawnEnemyInterval);
            finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'flex'; // Usar flex para centralizar
            playGameOverSound();
            Tone.Transport.stop();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // Cancela o loop de animação
                animationFrameId = null; // Reseta o ID
            }
        }

        // Eventos de controle
        // A lógica de detecção de mobile e atribuição de eventos é feita uma vez no início.
        // A visibilidade do botão de pausa é controlada em startGame().
        if (isMobile()) {
            canvas.addEventListener('touchstart', handleTouchMove, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            pauseButton.addEventListener('click', togglePause);
        } else {
            canvas.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('keydown', handleKeyDown);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (gameRunning && player && !isPaused) {
                const rect = canvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;

                player.x = touchX - player.width / 2;
                player.y = touchY - player.height / 2;

                if (player.x < 0) player.x = 0;
                if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                if (player.y < 0) player.y = 0;
                if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            }
        }

        function handleMouseMove(e) {
            if (gameRunning && player && !isPaused) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                player.x = mouseX - player.width / 2;
                player.y = mouseY - player.height / 2;

                if (player.x < 0) player.x = 0;
                if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                if (player.y < 0) player.y = 0;
                if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            }
        }

        function handleKeyDown(e) {
            if (e.key === ' ' || e.key === 'Escape') {
                togglePause();
            }
        }

        restartButton.addEventListener('click', () => {
            currentStage = 1; startGame();
        });
        startButton.addEventListener('click', startGame);
        settingsButton.addEventListener('click', () => {
            startScreen.style.display = 'none'; settingsScreen.style.display = 'flex';
        });
        backToStartButton.addEventListener('click', () => {
            settingsScreen.style.display = 'none'; startScreen.style.display = 'flex';
        });
        resumeButton.addEventListener('click', togglePause); // Botão de continuar na tela de pausa

        toggleShotSounds.addEventListener('change', (e) => { gameSettings.shotSoundsEnabled = e.target.checked; });
        toggleBackgroundMusic.addEventListener('change', (e) => {
            gameSettings.backgroundMusicEnabled = e.target.checked;
            if (gameSettings.backgroundMusicEnabled) {
                if (Tone.context.state === 'running') { backgroundMusic.start(0); Tone.Transport.start(); }
            } else {
                backgroundMusic.stop();
            }
        });

        window.onload = function() {
            // initSounds() será chamado dentro de startGame() após o Tone.start()
        };
    </script>
</body>
</html>
