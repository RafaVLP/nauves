<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Space Shooter: Boss Fight</title>
    <!-- Certifique-se de que o arquivo phaser.min.js (v3.80.1 ou superior) está na mesma pasta -->
    <script src="phaser.min.js"></script>
    <style>
        /* --- Configurações Globais --- */
        :root {
            --ui-blue: #00d8ff;
            --ui-green: #00ff8c;
            --ui-red: #ff4d4d;
            --ui-yellow-crit: #ffc700;
            --ui-bg-color: rgba(10, 25, 47, 0.75);
            --ui-border-color: rgba(0, 216, 255, 0.5);
            --dark-royal-blue: #061021;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--dark-royal-blue);
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh; /* Ocupa toda a altura da viewport */
            cursor: none;
            display: flex; /* Adicionado para centralizar o canvas */
            justify-content: center;
            align-items: center;
            /* Garante que o contêiner não seja maior que a tela */
            max-width: 100vw;
            max-height: 100vh;
        }

        canvas {
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 216, 255, 0.6);
            border: 2px solid var(--ui-blue);
            /* Garante que o canvas se ajuste ao contêiner */
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }
        
        /* --- Nova UI Arcade --- */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            /* AJUSTE: Padding responsivo usando vw e vh */
            padding: clamp(10px, 2.5vw, 25px); 
            box-sizing: border-box;
        }

        .ui-top, .ui-bottom {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            position: relative;
        }
        
        .ui-bottom {
            align-items: flex-end;
        }

        .info-panel {
            background: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            /* AJUSTE: Padding responsivo */
            padding: clamp(5px, 1.5vw, 15px) clamp(10px, 2.5vw, 25px);
            color: white;
            font-weight: 700;
            backdrop-filter: blur(5px);
            clip-path: polygon(0 0, 100% 0, 100% 100%, 10px 100%, 0 75%);
        }
        
        .info-panel.right {
             clip-path: polygon(0 0, 100% 0, 100% 75%, 95% 100%, 0 100%);
             text-align: right;
        }

        .info-panel .label {
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(0.7em, 1.8vw, 1em);
            color: var(--ui-blue);
            opacity: 0.8;
        }

        .info-panel .value {
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(1.2em, 3vw, 1.8em);
            text-shadow: 0 0 5px var(--ui-green);
        }

        /* --- Barra de Vida do Chefe --- */
        #boss-health-container {
            position: absolute;
            /* AJUSTE: Posição superior responsiva */
            top: clamp(60px, 8vh, 100px); 
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 50;
        }

        .boss-health-label {
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(0.9em, 2.2vw, 1.2em);
            font-weight: 700;
            color: var(--ui-red);
            text-shadow: 0 0 8px var(--ui-red);
        }

        .boss-health-bar-background {
            width: 100%;
            /* AJUSTE: Altura responsiva */
            height: clamp(15px, 2.5vw, 20px); 
            background-color: var(--ui-bg-color);
            border: 2px solid var(--ui-red);
            border-radius: 5px;
            padding: 2px;
        }

        #boss-health-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff4500, var(--ui-red));
            border-radius: 3px;
            transition: width 0.2s ease-out;
        }
        
        .player-stats-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Ajusta a largura para não sobrepor os botões, usando calc com clamp */
            width: calc(100% - clamp(80px, 15vw, 100px)); 
            pointer-events: auto;
        }

        .bars-container {
            position: relative;
            width: 100%;
            /* AJUSTE: Altura responsiva */
            height: clamp(20px, 3vw, 25px); 
            margin-bottom: clamp(5px, 1.5vw, 10px);
        }
        
        .progress-bar-background {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            clip-path: polygon(0 5px, 5px 0, calc(100% - 5px) 0, 100% 5px, 100% calc(100% - 5px), calc(100% - 5px) 100%, 5px 100%, 0 calc(100% - 5px));
            backdrop-filter: blur(5px);
        }
        
        .progress-bar-fill {
            height: 100%;
            transition: width 0.2s ease-out;
            position: relative;
            clip-path: polygon(0 5px, 5px 0, calc(100% - 5px) 0, 100% 5px, 100% calc(100% - 5px), calc(100% - 5px) 100%, 5px 100%, 0 calc(100% - 5px));
        }

        #health-bar-fill {
            background: linear-gradient(90deg, var(--ui-red), #ff7878);
        }
        
        #shield-bar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 5px;
            background-color: var(--ui-blue);
            box-shadow: 0 0 8px var(--ui-blue);
            border-radius: 2px;
            transition: width 0.2s ease-out, opacity 0.3s ease-in-out;
            opacity: 0;
        }
        
        .bar-text {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(0.8em, 2vw, 1em);
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        .stats-icons-container {
            display: flex;
            /* AJUSTE: Gap responsivo */
            gap: clamp(10px, 2.5vw, 15px);
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .stat-item {
            display: flex;
            align-items: center;
            /* AJUSTE: Gap e padding responsivos */
            gap: clamp(5px, 1.5vw, 8px);
            background: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            padding: clamp(3px, 1vw, 5px) clamp(8px, 2vw, 12px);
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }
        
        .stat-icon-img {
            /* AJUSTE: Tamanho responsivo */
            width: clamp(20px, 3.5vw, 24px);
            height: clamp(20px, 3.5vw, 24px);
        }
        
        .stat-item .value {
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(1em, 2.5vw, 1.2em);
            font-weight: 700;
            color: var(--ui-green);
        }

        #shield-timer-container {
            display: flex;
            align-items: center;
            /* AJUSTE: Gap e padding responsivos */
            gap: clamp(5px, 1.5vw, 8px);
            background: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            padding: clamp(3px, 1vw, 5px) clamp(8px, 2vw, 12px);
            border-radius: 5px;
            backdrop-filter: blur(5px);
            /* AJUSTE: Largura responsiva */
            width: clamp(60px, 12vw, 70px);
            justify-content: center;
        }
        
        #shield-timer {
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(1em, 2.5vw, 1.2em);
            font-weight: 700;
            color: var(--ui-blue);
            text-shadow: 0 0 5px var(--ui-blue);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #shield-timer-icon {
             /* AJUSTE: Tamanho responsivo */
             width: clamp(20px, 3.5vw, 24px);
             height: clamp(20px, 3.5vw, 24px);
             opacity: 0.5;
        }
        
        /* Telas de Overlay */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
            backdrop-filter: blur(5px);
            z-index: 100;
        }

        .overlay-panel {
            background: var(--ui-bg-color);
            border: 2px solid var(--ui-border-color);
            /* AJUSTE: Padding responsivo */
            padding: clamp(20px, 5vw, 30px);
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px var(--ui-blue);
            /* AJUSTE: Largura máxima para telas maiores */
            max-width: 90%; 
        }

        .overlay-title {
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(2em, 7vw, 3em);
            font-weight: 700;
            margin: 0;
        }

        #game-over-title { color: var(--ui-red); text-shadow: 0 0 10px var(--ui-red); }
        #stage-clear-title { color: var(--ui-green); text-shadow: 0 0 10px var(--ui-green); }
        #pause-title { color: var(--ui-blue); text-shadow: 0 0 10px var(--ui-blue); }

        #final-score-label {
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(1em, 2.5vw, 1.2em);
            color: var(--ui-blue);
            margin-top: clamp(15px, 3vw, 20px);
        }

        #final-score-value {
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(2em, 6vw, 2.5em);
            color: var(--ui-green);
            text-shadow: 0 0 8px var(--ui-green);
        }

        .overlay-button {
            /* AJUSTE: Margin e padding responsivos */
            margin-top: clamp(20px, 5vw, 30px);
            padding: clamp(8px, 2.5vw, 10px) clamp(20px, 5vw, 30px);
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(1em, 2.5vw, 1.2em);
            font-weight: 700;
            color: #0a192f;
            background-color: var(--ui-blue);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .overlay-button:hover {
            background-color: #fff;
            box-shadow: 0 0 15px #fff;
        }
        
        /* Ranking */
        #ranking-container { margin-top: clamp(15px, 4vw, 25px); }
        #ranking-title { 
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(1.3em, 3.5vw, 1.5em); 
            color: var(--ui-blue); 
            margin-bottom: clamp(5px, 1.5vw, 10px); 
        }
        #ranking-list { list-style: none; padding: 0; margin: 0; }
        #ranking-list li { 
            /* AJUSTE: Font-size responsivo */
            font-size: clamp(0.9em, 2.2vw, 1.1em); 
            padding: 2px 0; 
        }

        /* MUDANÇA: Botões de Controle (Pause/Fullscreen) */
        .control-button-container {
            /* AJUSTE: Largura responsiva */
            width: clamp(40px, 8vw, 45px); 
            pointer-events: auto;
        }
        .control-button {
            /* AJUSTE: Tamanho responsivo */
            width: clamp(35px, 7vw, 40px);
            height: clamp(35px, 7vw, 40px);
            background-color: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .control-button svg { 
            /* AJUSTE: Tamanho responsivo */
            width: clamp(18px, 4vw, 20px); 
            height: clamp(18px, 4vw, 20px); 
            fill: var(--ui-blue); 
        }

        /* Media Query para telas menores (celulares) */
        @media (max-width: 600px) {
            #game-ui {
                padding: 1.5vw; /* Reduz um pouco mais o padding em telas muito pequenas */
            }

            .info-panel {
                padding: 1vw 2vw;
            }

            .info-panel .label {
                font-size: 0.65em;
            }

            .info-panel .value {
                font-size: 1.1em;
            }

            .player-stats-panel {
                width: calc(100% - 12vw); /* Ajusta para telas muito pequenas */
            }

            .stat-item {
                padding: 2px 5px;
            }

            .stat-icon-img {
                width: 18px;
                height: 18px;
            }

            .stat-item .value {
                font-size: 0.9em;
            }

            #shield-timer-container {
                width: 50px;
            }

            #shield-timer {
                font-size: 1em;
            }

            .overlay-panel {
                padding: 15px;
            }

            .overlay-title {
                font-size: 2.2em;
            }

            .overlay-button {
                padding: 8px 20px;
                font-size: 1em;
            }

            #ranking-title {
                font-size: 1.2em;
            }

            #ranking-list li {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Phaser renderiza o canvas aqui -->
        
        <div id="game-ui">
            <div class="ui-top">
                <div class="info-panel">
                    <div class="label">SCORE</div>
                    <div class="value" id="score-value">0</div>
                </div>
                <div class="info-panel right">
                    <div class="label">STAGE / LEVEL</div>
                    <div>
                        <span class="value" id="stage-value">1</span>
                        -
                        <span class="value" id="level-value" style="font-size: 1.1em; opacity: 0.9; color: #e0e0e0;">1</span>
                    </div>
                </div>
                <div id="boss-health-container">
                    <div class="boss-health-label">BOSS</div>
                    <div class="boss-health-bar-background">
                        <div id="boss-health-bar-fill"></div>
                    </div>
                </div>
            </div>

            <div class="ui-bottom">
                <div class="control-button-container">
                    <div id="fullscreen-button" class="control-button">
                        <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                    </div>
                </div>
                
                <div class="player-stats-panel">
                    <div class="bars-container">
                        <div class="progress-bar-background"></div>
                        <div id="health-bar-fill" class="progress-bar-fill" style="width: 100%;"></div>
                        <div id="shield-bar-overlay"></div>
                        <div id="health-bar-text" class="bar-text"></div>
                    </div>
                    <div class="stats-icons-container">
                        <div class="stat-item">
                            <img id="damage-icon" class="stat-icon-img" src="Damage_Bonus.png" alt="Damage Icon"/>
                            <span class="value" id="damage-value">1</span>
                        </div>
                        <div class="stat-item">
                            <img id="cannons-icon" class="stat-icon-img" src="Rockets_Bonus.png" alt="Cannons Icon"/>
                            <span class="value" id="cannons-value">1</span>
                        </div>
                        <div id="shield-timer-container">
                            <img id="shield-timer-icon" class="stat-icon-img" src="Armor_Bonus.png" alt="Shield Timer Icon"/>
                            <span id="shield-timer">30s</span>
                        </div>
                    </div>
                </div>

                <div class="control-button-container">
                    <div id="pause-button" class="control-button">
                        <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="game-over-screen" class="overlay-screen">
            <div id="game-over-panel" class="overlay-panel">
                <h1 id="game-over-title" class="overlay-title">GAME OVER</h1>
                <div id="final-score-label">SCORE FINAL</div>
                <div id="final-score-value">0</div>
                <div id="ranking-container">
                    <h2 id="ranking-title">TOP 5</h2>
                    <ol id="ranking-list"></ol>
                </div>
                <button id="restart-button" class="overlay-button">REINICIAR</button>
            </div>
        </div>
        
        <div id="stage-clear-screen" class="overlay-screen">
            <div id="stage-clear-panel" class="overlay-panel">
                <h1 id="stage-clear-title" class="overlay-title">STAGE CLEAR!</h1>
                <button id="next-stage-button" class="overlay-button">PROSSEGUIR</button>
            </div>
        </div>
        
        <div id="pause-screen" class="overlay-screen">
            <div id="pause-panel" class="overlay-panel">
                <h1 id="pause-title" class="overlay-title">PAUSADO</h1>
                <button id="resume-button" class="overlay-button">RETOMAR</button>
            </div>
        </div>

    </div>

    <script>
        // --- Variáveis Globais do Jogo ---
        let player, playerBullets, enemies, meteors, enemyBullets, bossBullets, powerUps, stars;
        let score = 0;
        let playerHealth = 100, playerMaxHealth = 100, playerDamage = 1;
        let extraShots = 0;
        const MAX_EXTRA_SHOTS = 2;
        let shieldAmount = 0, shieldDuration = 30;
        const SHIELD_MAX_DURATION = 30, SHIELD_MAX_VALUE = 100;
        let shieldTimerEvent;

        let baseEnemyLevel = 1, currentStage = 1, scoreToNextBoss = 100;
        let bossFightActive = false, bossObject = null;
        
        let enemySpawnTimer, meteorSpawnTimer;

        let lightPool = [];
        const MAX_LIGHTS = 50;
        let explosionEmitter;

        const PLAYER_SPRITE_WIDTH = 120, PLAYER_SPRITE_HEIGHT = 120;
        const ENEMY_SPRITE_WIDTH = 120, ENEMY_SPRITE_HEIGHT = 120;
        const BOSS_SPRITE_WIDTH = 240, BOSS_SPRITE_HEIGHT = 240;
        const BULLET_SPRITE_WIDTH = 32, BULLET_SPRITE_HEIGHT = 32;
        const POWERUP_SPRITE_SIZE = 24;

        let scoreTextElement, baseEnemyLevelUITextElement, healthBarFillElement, 
            healthTextElement, shieldBarOverlayElement, shieldTimerElement, 
            damageTextElement, extraShotsTextElement, stageTextElement,
            bossHealthContainerElement, bossHealthBarFillElement;
        
        let isPaused = false;

        // --- Configuração do Phaser ---
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth, // Define a largura inicial como a largura da janela
            height: window.innerHeight, // Define a altura inicial como a altura da janela
            parent: 'game-container',
            backgroundColor: '#061021',
            scale: {
                mode: Phaser.Scale.RESIZE, // Alterado para RESIZE para melhor adaptação
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false 
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        // --- Funções Principais do Phaser ---

        function preload() {
            this.load.image('player_sprite', 'player1.png');
            this.load.image('enemy1_sprite', 'enemy1.png');
            this.load.image('boss_sprite', 'boss.png'); 
            this.load.image('player_bullet_sprite', 'player_bullet.png');
            this.load.image('enemy_bullet_sprite', 'enemy_bullet.png'); 
            this.load.image('powerup_damage', 'Damage_Bonus.png');
            this.load.image('powerup_health', 'HP_Bonus.png');
            this.load.image('powerup_extraShot', 'Rockets_Bonus.png');
            this.load.image('powerup_shield', 'Armor_Bonus.png');
            this.load.atlas('flares', 'https://labs.phaser.io/assets/particles/flares.png', 'https://labs.phaser.io/assets/particles/flares.json');
            
            for (let i = 1; i <= 10; i++) {
                const num = i < 10 ? `0${i}` : i;
                this.load.image(`Meteor_${num}`, `Meteor_${num}.png`);
            }
        }

        function create() {
            setupVisuals.call(this);
            setupPlayer.call(this);
            setupGroups.call(this);
            setupUI.call(this);
            setupTimers.call(this);
            setupInput.call(this);
            setupCollisions.call(this);

            // Listener para redimensionamento da janela
            this.scale.on('resize', resizeGame, this);
            resizeGame.call(this, this.scale.gameSize); // Chama a função de redimensionamento na criação para ajustar o canvas
        }

        function update() {
            if (!player.active || isPaused) return;

            stars.children.each(star => {
                if (star && star.y > this.scale.height + 10) star.destroy(); // Usa this.scale.height
            });
            
            if (player.shieldSprite) player.shieldSprite.setPosition(player.x, player.y);

            if (!bossFightActive && score >= scoreToNextBoss) {
                 startBossFight.call(this);
            }
        }
        
        // Função para redimensionar o jogo e o canvas
        function resizeGame(gameSize) {
            const { width, height } = gameSize;
            this.cameras.main.setSize(width, height);
            // Atualiza a posição do player e outros elementos se necessário
            if (player) {
                player.x = width / 2;
                player.y = height - 100;
            }
            // Se houver elementos que dependem da largura/altura do jogo, ajuste-os aqui
        }

        // --- Funções de Setup ---

        function setupVisuals() {
            const interFont = document.createElement('link');
            interFont.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap';
            interFont.rel = 'stylesheet';
            document.head.appendChild(interFont);
            
            const graphics = this.add.graphics();
            graphics.fillStyle(0xffffff, 1);
            graphics.fillCircle(2, 2, 2);
            graphics.generateTexture('star_particle', 4, 4);
            graphics.fillStyle(0x00aeff, 0.5);
            graphics.fillCircle(48, 48, 48);
            graphics.generateTexture('shield_glow_particle', 96, 96);
            graphics.destroy();

            this.lights.enable();
            this.lights.setAmbientColor(0x606060); 
            
            for (let i = 0; i < MAX_LIGHTS; i++) {
                const light = this.lights.addLight(0, 0, 100, 0xffffff, 0).setVisible(false);
                lightPool.push(light);
            }

            stars = this.physics.add.group();

            explosionEmitter = this.add.particles(0, 0, 'flares', {
                frame: [ 'yellow', 'orange' ],
                lifespan: 1000,
                speed: { min: 100, max: 300 },
                scale: { start: 0.5, end: 0 },
                gravityY: 500,
                blendMode: 'ADD',
                emitting: false
            });
        }

        function setupPlayer() {
            // Posiciona o player com base na largura e altura atual do jogo
            player = this.add.sprite(this.scale.width / 2, this.scale.height - 100, 'player_sprite');
            player.shieldSprite = this.add.sprite(player.x, player.y, 'shield_glow_particle')
                .setBlendMode('ADD')
                .setDepth(player.depth - 1)
                .setVisible(false);

            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);
            
            const playerHitboxWidth = PLAYER_SPRITE_WIDTH * 0.70;
            const playerHitboxHeight = PLAYER_SPRITE_HEIGHT * 0.97;
            player.body.setSize(playerHitboxWidth, playerHitboxHeight)
                .setOffset((PLAYER_SPRITE_WIDTH - playerHitboxWidth) / 1.7, (PLAYER_SPRITE_HEIGHT - playerHitboxHeight) / 2);

            player.setPipeline('Light2D');
        }

        function setupGroups() {
            playerBullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 30 });
            enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });
            meteors = this.physics.add.group({ classType: Meteor, runChildUpdate: true });
            enemyBullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 100 });
            bossBullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 100 });
            powerUps = this.physics.add.group({ classType: PowerUp, runChildUpdate: true });
        }

        function setupUI() {
            // Mapeamento de elementos
            const ids = ['score-value', 'level-value', 'stage-value', 'health-bar-fill', 'health-bar-text', 'shield-bar-overlay', 'shield-timer', 'damage-value', 'cannons-value', 'boss-health-container', 'boss-health-bar-fill'];
            [scoreTextElement, baseEnemyLevelUITextElement, stageTextElement, healthBarFillElement, healthTextElement, shieldBarOverlayElement, shieldTimerElement, damageTextElement, extraShotsTextElement, bossHealthContainerElement, bossHealthBarFillElement] = ids.map(id => document.getElementById(id));
            
            // Event Listeners dos botões
            document.getElementById('restart-button').addEventListener('click', () => {
                document.getElementById('game-over-screen').style.opacity = '0';
                document.getElementById('game-over-screen').style.visibility = 'hidden';
                resetGameVariables();
                this.scene.restart();
            });
            
            document.getElementById('next-stage-button').addEventListener('click', () => startNextStage.call(this));
            document.getElementById('resume-button').addEventListener('click', () => togglePause.call(this));
            document.getElementById('pause-button').addEventListener('click', () => togglePause.call(this));
            
            // Adiciona listener para o botão de fullscreen
            document.getElementById('fullscreen-button').addEventListener('click', () => {
                if (this.scale.isFullscreen) {
                    this.scale.stopFullscreen();
                } else {
                    this.scale.startFullscreen();
                }
            });

            updateUI(); 
        }

        function setupTimers() {
            this.time.addEvent({ delay: 50, callback: spawnStar, callbackScope: this, loop: true });
            this.time.addEvent({ delay: 400, callback: firePlayerBullet, callbackScope: this, loop: true });
            enemySpawnTimer = this.time.addEvent({ delay: 2700, callback: spawnEnemy, callbackScope: this, loop: true });
            meteorSpawnTimer = this.time.addEvent({ delay: 6338, callback: spawnMeteor, callbackScope: this, loop: true });
        }

        function setupInput() {
            this.input.on('pointermove', (pointer) => {
                // Remove a condição !pointer.isDown para permitir movimento contínuo no toque
                if(player.active) {
                    this.tweens.add({
                        targets: player,
                        x: pointer.x,
                        y: pointer.y,
                        duration: 100,
                        ease: 'Sine.easeOut'
                    });
                }
            }, this);

            // Pausar com a barra de espaço
            this.input.keyboard.on('keydown-SPACE', () => togglePause.call(this));
        }

        function setupCollisions() {
            this.physics.add.overlap(playerBullets, meteors, handlePlayerHit, null, this);
            this.physics.add.overlap(playerBullets, enemies, handlePlayerHit, null, this);
            
            this.physics.add.overlap(player, meteors, hitPlayerByMeteor, null, this);
            this.physics.add.overlap(player, enemyBullets, (p, b) => hitPlayer(p, b, this), null, this);
            this.physics.add.overlap(player, bossBullets, (p, b) => hitPlayer(p, b, this), null, this);
            this.physics.add.overlap(player, enemies, (p, e) => hitPlayerByEnemy(p, e, this), null, this);
            this.physics.add.overlap(player, powerUps, collectPowerUp, null, this);
        }

        // --- Classes do Jogo ---

        class Bullet extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, null);
                this.type = ''; this.damage = 0; this.light = null; this.bounces = 0; this.justBounced = false;
            }

            fire(x, y, vx, vy, type, damage, bounces = 0) {
                Object.assign(this, { type, damage, bounces });
                this.setTexture(type === 'playerBullet' ? 'player_bullet_sprite' : 'enemy_bullet_sprite');
                this.enableBody(true, x, y, true, true);
                
                const bulletHitboxSize = BULLET_SPRITE_WIDTH * 0.97;
                this.body.setSize(bulletHitboxSize, bulletHitboxSize).setOffset((BULLET_SPRITE_WIDTH - bulletHitboxSize) / 2, (BULLET_SPRITE_HEIGHT - bulletHitboxSize) / 2);

                this.setVelocity(vx, vy).setPipeline('Light2D');
                
                if (this.bounces > 0) this.body.setCollideWorldBounds(true).setBounce(1);

                this.light = getLightFromPool();
                if (this.light) {
                    const color = this.type === 'playerBullet' ? 0x00ffff : 0xff8c00;
                    this.light.setPosition(x, y).setColor(color).setRadius(250).setVisible(true);
                    this.scene.tweens.add({ targets: this.light, intensity: 1.5, duration: 100, ease: 'Sine.easeIn' });
                }
            }
            
            kill() {
                if (!this.active) return;
                if (this.light && this.light.visible) {
                    const lightToFade = this.light;
                    this.scene.tweens.add({
                        targets: lightToFade, intensity: 0, duration: 100, ease: 'Sine.easeOut',
                        onComplete: () => lightToFade.setVisible(false)
                    });
                    this.light = null;
                }
                this.disableBody(true, true);
            }

            preUpdate(time, delta) {
                super.preUpdate(time, delta);
                if (!this.active) return;
                if (this.light) this.light.setPosition(this.x, this.y);
                
                if (this.bounces > 0) {
                    if (this.body.blocked.left || this.body.blocked.right) {
                        if (!this.justBounced) {
                            this.bounces--; this.justBounced = true;
                            this.scene.time.delayedCall(50, () => { this.justBounced = false; });
                        }
                    }
                    if (this.bounces <= 0) {
                        this.body.setCollideWorldBounds(false);
                        this.scene.time.delayedCall(1000, () => this.kill());
                    }
                } else if (this.y < -20 || this.y > this.scene.scale.height + 20 || this.x < -20 || this.x > this.scene.scale.width + 20) {
                    this.kill();
                }
            }
        }
        
        class Meteor extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, null);
                scene.add.existing(this); scene.physics.add.existing(this);
                this.body.allowGravity = false; this.setOrigin(0.5);
                this.health = 1; this.initialHealth = 1;
                this.healthBarBackground = scene.add.rectangle(0, 0, 1, 5, 0x555555).setOrigin(0.5, 0.5);
                this.healthBar = scene.add.rectangle(0, 0, 1, 5, 0xcccccc).setOrigin(0.5, 0.5);
            }

            spawn(x, y) {
                const meteorType = Phaser.Math.Between(1, 10);
                const num = meteorType < 10 ? `0${meteorType}` : meteorType;
                this.setTexture(`Meteor_${num}`);

                this.setScale(Phaser.Math.FloatBetween(0.8, 1.2) * 0.27);
                
                const baseHealth = Phaser.Math.Between(7, 13);
                this.health = Math.ceil(baseHealth * (1 + baseEnemyLevel * 0.2));
                this.initialHealth = this.health;

                this.enableBody(true, x, y, true, true);
                this.body.setSize(this.width * 0.97, this.height * 0.97);

                this.setVelocityY(Phaser.Math.Between(80, 150)).setAngularVelocity(Phaser.Math.Between(-50, 50)).setPipeline('Light2D');

                this.healthBarBackground.setVisible(true); this.healthBar.setVisible(true);
                this.updateHealthBar();
            }

            takeDamage(amount) {
                this.health -= amount;
                this.updateHealthBar();
                if (this.health <= 0) this.kill();
            }

            kill() {
                if (!this.active) return;
                this.healthBarBackground.setVisible(false); this.healthBar.setVisible(false);
                createExplosionLight(this.x, this.y, this.scene);
                if (explosionEmitter) explosionEmitter.explode(15, this.x, this.y);
                this.dropPowerUp();
                this.disableBody(true, true);
            }
            
            dropPowerUp() {
                if (Math.random() < 0.25) {
                    let type = bossFightActive ? (Math.random() < 0.5 ? 'health' : 'shield') : ['damage', 'health', 'extraShot', 'shield'][Phaser.Math.Between(0,3)];
                    const powerUp = powerUps.get(this.x, this.y);
                    if (powerUp) powerUp.spawn(this.x, this.y, type);
                }
            }

            updateHealthBar() {
                const barWidth = this.displayWidth * 0.8;
                const barHeight = 5;
                const yOffset = this.displayHeight / 2 + 10;
                this.healthBarBackground.setPosition(this.x, this.y + yOffset).setSize(barWidth, barHeight);
                const healthRatio = this.health / this.initialHealth;
                this.healthBar.setPosition(this.x - (barWidth * (1 - healthRatio) / 2), this.y + yOffset).setSize(barWidth * healthRatio, barHeight);
            }

            preUpdate(time, delta) {
                super.preUpdate(time, delta);
                if(this.active) {
                    this.updateHealthBar();
                    if (this.y > this.scene.scale.height + this.displayHeight) this.kill(); // Usa this.scene.scale.height
                }
            }
        }

        class Enemy extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, null);
                scene.add.existing(this); scene.physics.add.existing(this);
                this.body.allowGravity = false; this.setOrigin(0.5);
                this.health = 1; this.initialHealth = 1; this.speed = 100; this.isBoss = false; this.isEnraged = false;
                this.level = 1; this.damage = 1;
                this.fireTimer = scene.time.addEvent({ delay: 1, callback: this.fireBullet, callbackScope: this, loop: true, paused: true });
                this.healthBarBackground = scene.add.rectangle(0, 0, 1, 5, 0x555555).setOrigin(0.5, 0.5);
                this.healthBar = scene.add.rectangle(0, 0, 1, 5, 0xff4500).setOrigin(0.5, 0.5);
                this.levelText = scene.add.text(0, 0, '', { fontSize: '10px', fill: '#fff', fontFamily: 'Inter' }).setOrigin(0.5).setDepth(1);
                this.horizontalTween = null; this.verticalTween = null;
            }

            spawn(x, y, isBoss = false, level = 1) {
                this.enableBody(true, x, y, true, true);
                this.level = level;
                if (this.horizontalTween) this.horizontalTween.stop();
                if (this.verticalTween) this.verticalTween.stop();
                this.setPipeline('Light2D');
                
                this.isBoss = isBoss;
                if (isBoss) this.spawnAsBoss(x, y);
                else this.spawnAsMinion(x, y, level);
                
                this.setVisible(true).setActive(true);
                this.levelText.setVisible(!isBoss);
                this.fireTimer.paused = false;
                this.updateHealthBar();
            }

            spawnAsMinion(x, y, level) {
                this.setTexture('enemy1_sprite');
                
                const baseHealth = 3;
                this.health = Math.ceil(baseHealth * (1 + level * 0.2));
                this.initialHealth = this.health;
                this.damage = 5 + (level - 1);

                const baseEnemySpeed = 100;
                const levelSpeedIncreaseFactor = Math.min((level - 1) * 0.05, 0.8);
                this.speed = baseEnemySpeed * (1 + levelSpeedIncreaseFactor);
                this.setVelocityY(this.speed);
                
                const enemyHitboxWidth = ENEMY_SPRITE_WIDTH * 0.70;
                const enemyHitboxHeight = ENEMY_SPRITE_HEIGHT * 0.97;
                this.body.setSize(enemyHitboxWidth, enemyHitboxHeight).setOffset((ENEMY_SPRITE_WIDTH - enemyHitboxWidth) / 1.7, (ENEMY_SPRITE_HEIGHT - enemyHitboxHeight) / 2);

                this.fireTimer.delay = 2700 - (level * 20);
                this.fireTimer.callback = this.fireBullet;

                let tintColor = 0xFFFFFF;
                if (level >= 2) tintColor = 0xADD8E6; if (level >= 4) tintColor = 0x90EE90;
                if (level >= 6) tintColor = 0xFFD700; if (level >= 8) tintColor = 0xFFA500;
                if (level >= 10) tintColor = 0xFF4500; if (level >= 15) tintColor = 0xDA70D6;
                if (level >= 20) tintColor = 0xFF0000;
                this.setTint(tintColor);
                this.levelText.setText(`Lv${level}`);
                this.healthBar.setVisible(true); this.healthBarBackground.setVisible(true);
            }

            spawnAsBoss(x, y) {
                this.setTexture('boss_sprite');
                this.setScale(0.3).setAlpha(1).setAngle(180).setDepth(10);
                
                const healthMultiplier = Math.pow(1.3, currentStage - 1);
                const damageMultiplier = Math.pow(1.3, currentStage - 1);
                const speedMultiplier = Math.pow(1.05, currentStage - 1);

                this.health = 600 * healthMultiplier;
                this.initialHealth = this.health;
                this.damage = 15 * damageMultiplier;
                this.isEnraged = false;

                const bossHitboxWidth = this.width * 0.8;
                const bossHitboxHeight = this.height * 0.8;
                this.body.setSize(bossHitboxWidth, bossHitboxHeight).setOffset((this.width - bossHitboxWidth) / 2, (this.height - bossHitboxHeight) / 2);

                this.fireTimer.delay = 1500;
                this.fireTimer.callback = this.fireBossPattern;

                this.scene.tweens.add({
                    targets: this, y: 150, duration: 2000, ease: 'Cubic.easeOut',
                    onComplete: () => {
                        this.horizontalTween = this.scene.tweens.add({ targets: this, x: { from: 80, to: this.scene.scale.width - 80 }, ease: 'Sine.easeInOut', duration: 3000 / speedMultiplier, repeat: -1, yoyo: true }); // Usa this.scene.scale.width
                        this.verticalTween = this.scene.tweens.add({ targets: this, y: { from: 120, to: 220 }, ease: 'Sine.easeInOut', duration: 1875 / speedMultiplier, repeat: -1, yoyo: true });
                    }
                });

                this.healthBar.setVisible(false); this.healthBarBackground.setVisible(false);
            }

            fireBullet() {
                if (!this.active) return;
                const bullet = enemyBullets.get();
                if (bullet) bullet.fire(this.x, this.y + this.displayHeight / 2 + 10, 0, this.speed * 2.5, 'enemyBullet', this.damage);
            }

            fireBossPattern() {
                if (!this.active || !player.active) return;
                const pattern = Phaser.Math.Between(1, 3);
                switch(pattern) {
                    case 1: this.fireStraightShot(); break;
                    case 2: this.fireSpreadShot(); break;
                    case 3: this.fireRicochetShot(); break;
                }
            }

            fireStraightShot() {
                const angle = Phaser.Math.Angle.Between(this.x, this.y, player.x, player.y);
                const vx = Math.cos(angle) * 300;
                const vy = Math.sin(angle) * 300;
                const bullet = bossBullets.get();
                if (bullet) bullet.fire(this.x, this.y, vx, vy, 'enemyBullet', this.damage);
            }

            fireSpreadShot() {
                const shots = this.isEnraged ? 12 : 8;
                for (let i = 0; i < shots; i++) {
                    const angle = Phaser.Math.DegToRad((360 / shots) * i);
                    const vx = Math.cos(angle) * 250;
                    const vy = Math.sin(angle) * 250;
                    const bullet = bossBullets.get();
                    if (bullet) bullet.fire(this.x, this.y, vx, vy, 'enemyBullet', this.damage);
                }
            }

            fireRicochetShot() {
                const bullet = bossBullets.get();
                if (bullet) {
                    const vx = Phaser.Math.Between(1,2) === 1 ? -200 : 200;
                    bullet.fire(this.x, this.y, vx, 200, 'enemyBullet', this.damage, 2);
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                this.updateHealthBar();
                
                this.setTint(0xff0000);
                this.scene.time.delayedCall(100, () => {
                    if (this.active) {
                       this.clearTint();
                       if (this.isEnraged) this.setTint(0xff6666);
                    }
                });

                if (this.health <= 0) {
                    this.kill();
                } else if (this.isBoss && !this.isEnraged && (this.health / this.initialHealth) <= 0.35) {
                    this.enrage();
                }
            }

            enrage() {
                this.isEnraged = true;
                this.setTint(0xff6666);
                if (this.horizontalTween) this.horizontalTween.timeScale *= 1.35;
                if (this.verticalTween) this.verticalTween.timeScale *= 1.35;
                this.fireTimer.delay = 1000;
                this.damage *= 1.35;

                let rageText = this.scene.add.text(this.x, this.y - 50, 'ENRAGED!', { fontSize: '24px', fill: '#ff0000', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);
                this.scene.tweens.add({
                    targets: rageText, alpha: 0, y: '-=50', duration: 1500,
                    onComplete: () => rageText.destroy()
                });
            }
            
            kill() {
                if (!this.active) return;
                this.setActive(false);
                createExplosionLight(this.x, this.y, this.scene);
                this.fireTimer.paused = true;
                this.healthBarBackground.setVisible(false); this.healthBar.setVisible(false); this.levelText.setVisible(false);
                if (this.horizontalTween) this.horizontalTween.stop();
                if (this.verticalTween) this.verticalTween.stop();
                if (explosionEmitter) explosionEmitter.explode(this.isBoss ? 100 : 30, this.x, this.y);
                
                if (!this.isBoss) {
                    score += this.level;
                    updateUI();
                    this.dropPowerUp();
                } else {
                    score += 50 * currentStage;
                    bossObject = null;
                    bossFightActive = false;
                    this.scene.time.delayedCall(2000, () => endBossFight.call(this.scene));
                }
                
                this.disableBody(true, true);
            }

            dropPowerUp() {
                if (Math.random() < 0.1) {
                    const type = ['damage', 'health', 'extraShot', 'shield'][Phaser.Math.Between(0,3)];
                    const powerUp = powerUps.get(this.x, this.y);
                    if (powerUp) powerUp.spawn(this.x, this.y, type);
                }
            }

            updateHealthBar() {
                const healthRatio = this.health / this.initialHealth;
                if (this.isBoss) {
                    if(bossHealthBarFillElement) bossHealthBarFillElement.style.width = `${healthRatio * 100}%`;
                } else {
                    const barWidth = this.displayWidth * 0.6;
                    const yOffset = this.y - this.displayHeight / 2 - 15;
                    const xOffset = this.x;

                    this.healthBarBackground.setPosition(xOffset, yOffset).setSize(barWidth, 5).setOrigin(0.5, 0.5);
                    this.healthBar.setPosition(xOffset - (barWidth * (1 - healthRatio) / 2), yOffset).setSize(barWidth * healthRatio, 5).setOrigin(0.5, 0.5);
                    this.healthBar.setFillStyle(0x00ff00);
                }
            }

            preUpdate(time, delta) {
                super.preUpdate(time, delta);
                if (this.active && !this.isBoss) {
                    this.updateHealthBar();
                    this.levelText.setPosition(this.x, this.y - this.displayHeight / 2 - 35);
                    if (this.y > this.scene.scale.height + 50) this.kill(); // Usa this.scene.scale.height
                }
            }
        }

        class PowerUp extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, null);
                scene.add.existing(this); scene.physics.add.existing(this);
                this.body.allowGravity = false; this.setOrigin(0.5); this.type = '';
            }

            spawn(x, y, type) {
                this.enableBody(true, x, y, true, true);
                this.type = type;
                this.setTexture('powerup_' + type);
                this.setVelocityY(100).setPipeline('Light2D');
                this.body.setSize(POWERUP_SPRITE_SIZE, POWERUP_SPRITE_SIZE);
            }

            preUpdate(time, delta) {
                super.preUpdate(time, delta);
                if (this.y > this.scene.scale.height + 50) this.disableBody(true, true); // Usa this.scene.scale.height
            }
        }

        // --- Funções de Lógica do Jogo ---

        function firePlayerBullet() {
            if (!player.active) return;
            const baseVy = -400;
            const bulletSpawnY = player.y - player.displayHeight / 2;
            let bullet = playerBullets.get();
            if (bullet) bullet.fire(player.x, bulletSpawnY, 0, baseVy, 'playerBullet', playerDamage);
            const offset = 20;
            if (extraShots >= 1) {
                let bulletLeft = playerBullets.get();
                if (bulletLeft) bulletLeft.fire(player.x - offset, bulletSpawnY, 0, baseVy, 'playerBullet', playerDamage);
            }
            if (extraShots >= 2) {
                let bulletRight = playerBullets.get();
                if (bulletRight) bulletRight.fire(player.x + offset, bulletSpawnY, 0, baseVy, 'playerBullet', playerDamage);
            }
        }

        function spawnStar() {
            const x = Phaser.Math.Between(0, this.scale.width); // Usa this.scale.width
            const star = stars.create(x, -10, 'star_particle');
            if (star) {
                star.setVelocityY(Phaser.Math.Between(50, 200)).setScale(Phaser.Math.FloatBetween(0.2, 1)).setAlpha(star.scale * 0.8);
            }
        }

        function spawnEnemy() {
            if (bossFightActive) return;
            const x = Phaser.Math.Between(50, this.scale.width - 50); // Usa this.scale.width
            const enemyLevelToSpawn = (baseEnemyLevel <= 3) ? baseEnemyLevel : Phaser.Math.Between(baseEnemyLevel - 2, baseEnemyLevel);
            const enemy = enemies.get();
            if (enemy) enemy.spawn(x, -50, false, enemyLevelToSpawn);
        }
        
        function spawnMeteor() {
            const x = Phaser.Math.Between(50, this.scale.width - 50); // Usa this.scale.width
            const meteor = meteors.get();
            if (meteor) meteor.spawn(x, -100);
        }

        function startBossFight() {
            bossFightActive = true;
            enemySpawnTimer.paused = true;
            
            enemies.children.each(e => { if(e.active) e.kill(); });

            if(bossHealthContainerElement) bossHealthContainerElement.style.display = 'flex';

            let warningText = this.add.text(this.scale.width/2, this.scale.height/2, 'WARNING!', { fontSize: '60px', fill: '#ff0000', fontStyle: 'bold', stroke: '#000', strokeThickness: 8 }).setOrigin(0.5).setDepth(200).setAlpha(0); // Usa this.scale.width e this.scale.height
            this.tweens.add({
                targets: warningText, alpha: 1, scale: {from: 2, to: 1}, duration: 500, yoyo: true, hold: 1500,
                onComplete: () => {
                    warningText.destroy();
                    bossObject = enemies.get();
                    if (bossObject) bossObject.spawn(this.scale.width / 2, -100, true); // Usa this.scale.width
                }
            });
        }

        function endBossFight() {
            this.physics.pause();
            meteorSpawnTimer.paused = true;
            
            if(bossHealthContainerElement) bossHealthContainerElement.style.display = 'none';

            const screen = document.getElementById('stage-clear-screen');
            screen.style.visibility = 'visible';
            screen.style.opacity = '1';
        }

        function startNextStage() {
            const screen = document.getElementById('stage-clear-screen');
            screen.style.visibility = 'hidden';
            screen.style.opacity = '0';

            this.physics.resume();
            meteorSpawnTimer.paused = false;
            enemySpawnTimer.paused = false;

            currentStage++;
            scoreToNextBoss = Math.ceil(scoreToNextBoss * 1.40);
            
            playerDamage = baseEnemyLevel;

            updateUI();
        }
        
        function handlePlayerHit(bullet, target) {
            if (!bullet.active || !target.active) return;

            bullet.kill();

            let damageDealt = bullet.damage;
            const isCritical = Math.random() < 0.25;

            if (isCritical) {
                damageDealt *= 1.5;
                
                const critText = this.add.text(target.x, target.y, 'CRIT!', {
                    fontFamily: 'Inter', fontSize: '18px', fill: '#ffc700',
                    stroke: '#000000', strokeThickness: 4, fontStyle: 'bold'
                }).setOrigin(0.5).setDepth(200);
                
                const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
                const distance = 40;
                const targetX = target.x + Math.cos(angle) * distance;
                const targetY = target.y + Math.sin(angle) * distance;

                this.tweens.add({
                    targets: critText, x: targetX, y: targetY, alpha: 0, scale: 1.5, duration: 600, ease: 'Power3',
                    onComplete: () => critText.destroy()
                });
            }

            target.takeDamage(damageDealt);
        }

        function hitPlayerByMeteor(player, meteor) {
            applyDamageToPlayer(30, this);
            meteor.kill();
        }

        function hitPlayer(player, bullet, scene) {
            bullet.kill();
            applyDamageToPlayer(bullet.damage, scene);
        }

        function hitPlayerByEnemy(player, enemy, scene) {
            applyDamageToPlayer(enemy.damage, scene);
            enemy.kill();
        }

        function applyDamageToPlayer(damage, scene) {
            if (!player.active) return;
            
            scene.cameras.main.shake(100, 0.01);
            player.setTint(0xff0000);
            scene.time.delayedCall(100, () => player.clearTint());

            if (shieldAmount > 0) {
                shieldAmount -= damage;
                if (shieldAmount < 0) { playerHealth += shieldAmount; shieldAmount = 0; }
            } else {
                playerHealth -= damage;
            }

            if (playerHealth <= 0) { playerHealth = 0; gameOver.call(scene); }
            updateUI();
        }

        function collectPowerUp(player, powerUp) {
            powerUp.disableBody(true, true);
            switch (powerUp.type) {
                case 'damage': playerDamage++; break;
                case 'health': playerHealth = Math.min(playerMaxHealth, playerHealth + 20); break;
                case 'extraShot': if (extraShots < MAX_EXTRA_SHOTS) extraShots++; else score += 10; break;
                case 'shield':
                    shieldAmount = SHIELD_MAX_VALUE;
                    shieldDuration = SHIELD_MAX_DURATION;
                    if (shieldTimerEvent) shieldTimerEvent.destroy();
                    shieldTimerEvent = this.time.addEvent({ delay: 1000, callback: updateShieldDuration, callbackScope: this, loop: true });
                    player.shieldSprite.setVisible(true);
                    this.tweens.add({ targets: player.shieldSprite, alpha: { from: 0.7, to: 0.3 }, scale: { from: 1.2, to: 1.3 }, ease: 'Sine.easeInOut', duration: 500, yoyo: true, repeat: -1 });
                    break;
            }
            updateUI();
        }

        function updateShieldDuration() {
            if (shieldAmount > 0) {
                shieldDuration--;
                if (shieldDuration <= 0) {
                    shieldAmount = 0;
                    if (shieldTimerEvent) shieldTimerEvent.destroy();
                    this.tweens.killTweensOf(player.shieldSprite);
                    player.shieldSprite.setVisible(false);
                }
            }
            updateUI();
        }

        function updateUI() {
            if (scoreTextElement) scoreTextElement.textContent = score;
            
            let newBaseEnemyLevel = Math.floor(score / 50) + 1;
            if (newBaseEnemyLevel > baseEnemyLevel) baseEnemyLevel = newBaseEnemyLevel;
            if (baseEnemyLevelUITextElement) baseEnemyLevelUITextElement.textContent = baseEnemyLevel;
            if (stageTextElement) stageTextElement.textContent = currentStage;
            
            if (healthBarFillElement) {
                healthBarFillElement.style.width = `${(playerHealth / playerMaxHealth) * 100}%`;
                healthTextElement.textContent = `${Math.ceil(playerHealth)} / ${playerMaxHealth}`;
            }
            
            if (shieldBarOverlayElement) {
                if (shieldAmount > 0) {
                    shieldBarOverlayElement.style.opacity = '1';
                    shieldBarOverlayElement.style.width = `${(shieldAmount / SHIELD_MAX_VALUE) * 100}%`;
                    shieldTimerElement.style.opacity = '1';
                    shieldTimerElement.textContent = `${shieldDuration}s`;
                    document.getElementById('shield-timer-icon').style.opacity = '1';
                } else {
                    shieldBarOverlayElement.style.opacity = '0';
                    shieldTimerElement.style.opacity = '0';
                    document.getElementById('shield-timer-icon').style.opacity = '0.5';
                }
            }
            
            if (damageTextElement) damageTextElement.textContent = playerDamage;
            if (extraShotsTextElement) extraShotsTextElement.textContent = 1 + extraShots;
        }

        function gameOver() {
            if (!player.active) return;
            player.setActive(false);
            this.physics.pause();
            this.time.removeAllEvents();
            createExplosionLight(player.x, player.y, this);
            if (explosionEmitter) explosionEmitter.explode(50, player.x, player.y);
            if(player.shieldSprite) player.shieldSprite.setVisible(false);
            
            if(bossHealthContainerElement) bossHealthContainerElement.style.display = 'none';
            
            const gameOverScreen = document.getElementById('game-over-screen');
            document.getElementById('final-score-value').textContent = score;
            gameOverScreen.style.visibility = 'visible';
            gameOverScreen.style.opacity = '1';

            updateRanking(score);
        }

        function resetGameVariables() {
            score = 0; playerHealth = 100; playerDamage = 1; extraShots = 0;
            shieldAmount = 0; shieldDuration = SHIELD_MAX_DURATION;
            if (shieldTimerEvent) shieldTimerEvent.destroy();
            shieldTimerEvent = null;

            bossFightActive = false; bossObject = null;
            currentStage = 1; baseEnemyLevel = 1; scoreToNextBoss = 100;
            isPaused = false;
            
            if(bossHealthContainerElement) bossHealthContainerElement.style.display = 'none';
        }
        
        // --- Funções de Controle ---

        function togglePause() {
            isPaused = !isPaused;
            const pauseScreen = document.getElementById('pause-screen');
            if (isPaused) {
                this.scene.pause();
                pauseScreen.style.visibility = 'visible';
                pauseScreen.style.opacity = '1';
            } else {
                this.scene.resume();
                pauseScreen.style.visibility = 'hidden';
                pauseScreen.style.opacity = '0';
            }
        }
        
        // --- Funções de Ranking ---
        function getRanking() {
            const rankingJSON = localStorage.getItem('spaceShooterRanking');
            return rankingJSON ? JSON.parse(rankingJSON) : [];
        }

        function updateRanking(newScore) {
            let ranking = getRanking();
            const lowestScore = ranking.length < 5 ? 0 : ranking[4].score;

            if (newScore > lowestScore) {
                const name = prompt("Novo Recorde! Digite seu nome (3 caracteres):", "JOG");
                if (name) {
                    ranking.push({ name: name.substring(0, 3).toUpperCase(), score: newScore });
                    ranking.sort((a, b) => b.score - a.score);
                    ranking = ranking.slice(0, 5);
                    localStorage.setItem('spaceShooterRanking', JSON.stringify(ranking));
                }
            }
            displayRanking(ranking);
        }

        function displayRanking(ranking) {
            const listElement = document.getElementById('ranking-list');
            listElement.innerHTML = '';
            if (ranking.length === 0) {
                listElement.innerHTML = '<li>Nenhum recorde ainda!</li>';
            } else {
                ranking.forEach(entry => {
                    const li = document.createElement('li');
                    li.textContent = `${entry.name} - ${entry.score}`;
                    listElement.appendChild(li);
                });
            }
        }

        // --- Funções Utilitárias ---
        function getLightFromPool() {
            return lightPool.find(light => !light.visible) || null;
        }

        function createExplosionLight(x, y, scene) {
            const light = getLightFromPool();
            if (light) {
                light.setPosition(x, y).setColor(0xffff00).setRadius(350).setVisible(true);
                scene.tweens.add({
                    targets: light, intensity: { from: 6.0, to: 0 }, duration: 250, ease: 'Cubic.easeOut',
                    onComplete: () => light.setVisible(false)
                });
            }
        }
    </script>
</body>
</html>
