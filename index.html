<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Space Shooter: Boss Fight</title>
    <script src="phaser.min.js"></script>
    <!-- NOVO: Biblioteca de áudio para gerar sons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* --- Configurações Globais --- */
        :root {
            --ui-blue: #00d8ff;
            --ui-green: #00ff8c;
            --ui-red: #ff4d4d;
            --ui-yellow-crit: #ffc700;
            --ui-bg-color: rgba(10, 25, 47, 0.9);
            --ui-border-color: rgba(0, 216, 255, 0.5);
            --dark-royal-blue: #061021;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--dark-royal-blue);
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
        }

        #game-container {
            position: relative;
            width: 100vw;
            cursor: default; 
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--dark-royal-blue);
        }

        #game-container:fullscreen {
            width: 100%;
            height: 100%;
        }

        canvas {
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 216, 255, 0.6);
            border: 2px solid var(--ui-blue);
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }
        
        /* --- UI Arcade --- */
        #game-ui {
            position: absolute;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: clamp(10px, 2.5vw, 25px); 
            box-sizing: border-box;
            z-index: 10;
            pointer-events: none;
        }

        .ui-top, .ui-bottom {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            position: relative;
        }
        
        .ui-bottom {
            align-items: flex-end;
            gap: clamp(8px, 2vw, 15px);
        }

        .info-panel {
            background: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            padding: clamp(5px, 1.5vw, 15px) clamp(10px, 2.5vw, 25px);
            color: white;
            font-weight: 700;
            clip-path: polygon(0 0, 100% 0, 100% 100%, 10px 100%, 0 75%);
        }
        
        .info-panel.right {
             clip-path: polygon(0 0, 100% 0, 100% 75%, 95% 100%, 0 100%);
             text-align: right;
        }
        
        .blur-effect {
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .info-panel .label {
            font-size: clamp(0.7em, 1.8vw, 1em);
            color: var(--ui-blue);
            opacity: 0.8;
        }

        .info-panel .value {
            font-size: clamp(1.2em, 3vw, 1.8em);
            text-shadow: 0 0 5px var(--ui-green);
        }

        #boss-health-container {
            position: absolute;
            top: clamp(60px, 8vh, 100px); 
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 50;
        }

        .boss-health-label {
            font-size: clamp(0.9em, 2.2vw, 1.2em);
            font-weight: 700;
            color: var(--ui-red);
            text-shadow: 0 0 8px var(--ui-red);
        }

        .boss-health-bar-background {
            width: 100%;
            height: clamp(15px, 2.5vw, 20px); 
            background-color: var(--ui-bg-color);
            border: 2px solid var(--ui-red);
            border-radius: 5px;
            padding: 2px;
        }

        #boss-health-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff4500, var(--ui-red));
            border-radius: 3px;
            transition: width 0.2s ease-out;
        }
        
        .player-stats-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1;
            min-width: 0; 
            pointer-events: auto;
        }

        .bars-container {
            position: relative;
            width: 100%;
            height: clamp(20px, 3vw, 25px); 
            margin-bottom: clamp(5px, 1.5vw, 10px);
        }
        
        .progress-bar-background {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            clip-path: polygon(0 5px, 5px 0, calc(100% - 5px) 0, 100% 5px, 100% calc(100% - 5px), calc(100% - 5px) 100%, 5px 100%, 0 calc(100% - 5px));
        }
        
        .progress-bar-fill {
            height: 100%;
            transition: width 0.2s ease-out;
            position: relative;
            clip-path: polygon(0 5px, 5px 0, calc(100% - 5px) 0, 100% 5px, 100% calc(100% - 5px), calc(100% - 5px) 100%, 5px 100%, 0 calc(100% - 5px));
        }

        #health-bar-fill { background: linear-gradient(90deg, var(--ui-red), #ff7878); }
        
        #shield-bar-overlay {
            position: absolute;
            top: 0; left: 0; width: 0%; height: 5px;
            background-color: var(--ui-blue);
            box-shadow: 0 0 8px var(--ui-blue);
            border-radius: 2px;
            transition: width 0.2s ease-out, opacity 0.3s ease-in-out;
            opacity: 0;
        }
        
        .bar-text {
            position: absolute;
            width: 100%; height: 100%; top: 0; left: 0;
            display: flex; justify-content: center; align-items: center;
            font-size: clamp(0.8em, 2vw, 1em);
            font-weight: 700; color: white;
            text-shadow: 1px 1px 2px black;
        }

        .stats-icons-container {
            display: flex;
            gap: clamp(10px, 2.5vw, 15px);
            align-items: center; justify-content: center; width: 100%;
        }

        .stat-item {
            display: flex; align-items: center;
            gap: clamp(5px, 1.5vw, 8px);
            background: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            padding: clamp(3px, 1vw, 5px) clamp(8px, 2vw, 12px);
            border-radius: 5px; 
        }
        
        .stat-icon-img {
            width: clamp(20px, 3.5vw, 24px);
            height: clamp(20px, 3.5vw, 24px);
        }
        
        .stat-item .value {
            font-size: clamp(1em, 2.5vw, 1.2em);
            font-weight: 700; color: var(--ui-green);
        }

        #shield-timer-container {
            display: flex; align-items: center;
            gap: clamp(5px, 1.5vw, 8px);
            background: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            padding: clamp(3px, 1vw, 5px) clamp(8px, 2vw, 12px);
            border-radius: 5px; 
            width: clamp(60px, 12vw, 70px);
            justify-content: center;
        }
        
        #shield-timer {
            font-size: clamp(1em, 2.5vw, 1.2em);
            font-weight: 700; color: var(--ui-blue);
            text-shadow: 0 0 5px var(--ui-blue);
            opacity: 0; transition: opacity 0.3s ease-in-out;
        }
        #shield-timer-icon {
             width: clamp(20px, 3.5vw, 24px);
             height: clamp(20px, 3.5vw, 24px);
             opacity: 0.5;
        }
        
        /* Telas de Overlay */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
            opacity: 0; visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
            z-index: 100;
            pointer-events: all;
        }

        .overlay-panel {
            background: var(--ui-bg-color);
            border: 2px solid var(--ui-border-color);
            padding: clamp(20px, 5vw, 40px);
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px var(--ui-blue);
            max-width: 90%;
            width: 500px;
        }

        .overlay-title {
            font-size: clamp(2em, 7vw, 3em);
            font-weight: 700; margin: 0;
        }

        #game-over-title { color: var(--ui-red); text-shadow: 0 0 10px var(--ui-red); }
        #stage-clear-title { color: var(--ui-green); text-shadow: 0 0 10px var(--ui-green); }
        #pause-title { color: var(--ui-blue); text-shadow: 0 0 10px var(--ui-blue); }
        #start-title { color: var(--ui-blue); text-shadow: 0 0 10px var(--ui-blue); margin-bottom: 20px;}
        #settings-title { color: var(--ui-blue); text-shadow: 0 0 10px var(--ui-blue); margin-bottom: 25px;}

        #final-score-label {
            font-size: clamp(1em, 2.5vw, 1.2em);
            color: var(--ui-blue);
            margin-top: clamp(15px, 3vw, 20px);
        }

        #final-score-value {
            font-size: clamp(2em, 6vw, 2.5em);
            color: var(--ui-green);
            text-shadow: 0 0 8px var(--ui-green);
        }

        .overlay-button {
            margin-top: clamp(20px, 5vw, 30px);
            padding: clamp(12px, 3vw, 15px) clamp(25px, 6vw, 40px);
            font-size: clamp(1.1em, 3vw, 1.4em);
            font-weight: 700;
            color: #0a192f;
            background-color: var(--ui-blue);
            border: none; border-radius: 5px;
            cursor: pointer; pointer-events: all;
            transition: background-color 0.2s, box-shadow 0.2s, transform 0.2s;
        }
        .overlay-button:hover {
            background-color: #fff;
            box-shadow: 0 0 15px #fff;
            transform: scale(1.05);
        }
        
        #ranking-container { margin-top: clamp(15px, 4vw, 25px); }
        #ranking-title { 
            font-size: clamp(1.3em, 3.5vw, 1.5em); 
            color: var(--ui-blue); 
            margin-bottom: clamp(5px, 1.5vw, 10px); 
        }
        #ranking-list { list-style: none; padding: 0; margin: 0; }
        #ranking-list li { 
            font-size: clamp(0.9em, 2.2vw, 1.1em); 
            padding: 2px 0; 
        }

        .control-button-container {
            pointer-events: auto;
            flex-shrink: 0;
        }
        .control-button {
            width: clamp(40px, 9vw, 45px);
            height: clamp(40px, 9vw, 45px);
            background-color: var(--ui-bg-color);
            border: 1px solid var(--ui-border-color);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
        }
        .control-button svg { 
            width: clamp(20px, 5vw, 22px); 
            height: clamp(20px, 5vw, 22px); 
            fill: var(--ui-blue); 
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 300px;
            margin: 10px 0;
            font-size: clamp(1em, 3vw, 1.2em);
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--ui-green);
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .settings-description {
            font-size: clamp(0.8em, 2.2vw, 0.9em);
            color: #b0c4de;
            max-width: 320px;
            margin: 5px auto 15px auto;
            padding: 0 10px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Phaser renderiza o canvas aqui -->
        
        <div id="game-ui">
            <!-- UI Superior -->
            <div class="ui-top">
                <div class="info-panel">
                    <div class="label">SCORE</div>
                    <div class="value" id="score-value">0</div>
                </div>
                <div class="info-panel right">
                    <div class="label">STAGE / LEVEL</div>
                    <div>
                        <span class="value" id="stage-value">1</span>
                        -
                        <span class="value" id="level-value" style="font-size: 1.1em; opacity: 0.9; color: #e0e0e0;">1</span>
                    </div>
                </div>
                <div id="boss-health-container">
                    <div class="boss-health-label">BOSS</div>
                    <div class="boss-health-bar-background">
                        <div id="boss-health-bar-fill"></div>
                    </div>
                </div>
            </div>

            <!-- UI Inferior -->
            <div class="ui-bottom">
                <div class="control-button-container">
                    <div id="fullscreen-button" class="control-button">
                        <svg id="fullscreen-enter-icon" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                        <svg id="fullscreen-exit-icon" viewBox="0 0 24 24" style="display: none;"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>
                    </div>
                </div>
                
                <div class="player-stats-panel">
                    <div class="bars-container">
                        <div class="progress-bar-background"></div>
                        <div id="health-bar-fill" class="progress-bar-fill" style="width: 100%;"></div>
                        <div id="shield-bar-overlay"></div>
                        <div id="health-bar-text" class="bar-text"></div>
                    </div>
                    <div class="stats-icons-container">
                        <div class="stat-item">
                            <img id="damage-icon" class="stat-icon-img" src="Damage_Bonus.png" alt="Damage Icon"/>
                            <span class="value" id="damage-value">1</span>
                        </div>
                        <div class="stat-item">
                            <img id="cannons-icon" class="stat-icon-img" src="Rockets_Bonus.png" alt="Cannons Icon"/>
                            <span class="value" id="cannons-value">1</span>
                        </div>
                        <div id="shield-timer-container">
                            <img id="shield-timer-icon" class="stat-icon-img" src="Armor_Bonus.png" alt="Shield Timer Icon"/>
                            <span id="shield-timer">30s</span>
                        </div>
                    </div>
                </div>

                <div class="control-button-container">
                    <div id="pause-button" class="control-button">
                        <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    </div>
                </div>
            </div>

            <!-- Telas de Overlay -->
            <div id="start-screen" class="overlay-screen" style="visibility: visible; opacity: 1;">
                <div class="overlay-panel">
                    <h1 id="start-title" class="overlay-title">SPACE SHOOTER</h1>
                    <div class="menu-buttons">
                        <button id="start-game-button" class="overlay-button">INICIAR JOGO</button>
                        <button id="settings-button-main" class="overlay-button">CONFIGURAÇÕES</button>
                    </div>
                </div>
            </div>
            
            <div id="settings-screen" class="overlay-screen">
                <div class="overlay-panel">
                    <h1 id="settings-title" class="overlay-title">CONFIGURAÇÕES</h1>
                    <div class="settings-row">
                        <span>Melhor Desempenho</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="performance-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="settings-description">
                        Desativa efeitos visuais pesados para um jogo mais fluido. Recarregue a página para aplicar.
                    </div>
                    <hr style="border-color: var(--ui-border-color); width: 100%;">
                    <div class="settings-row">
                        <span>Música</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="music-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="settings-row">
                        <span>Efeitos Sonoros</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="sfx-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <button id="back-button" class="overlay-button">VOLTAR</button>
                </div>
            </div>

            <div id="game-over-screen" class="overlay-screen">
                <div id="game-over-panel" class="overlay-panel">
                    <h1 id="game-over-title" class="overlay-title">GAME OVER</h1>
                    <div id="final-score-label">SCORE FINAL</div>
                    <div id="final-score-value">0</div>
                    <div id="ranking-container">
                        <h2 id="ranking-title">TOP 5</h2>
                        <ol id="ranking-list"></ol>
                    </div>
                    <button id="restart-button" class="overlay-button">REINICIAR</button>
                </div>
            </div>
            
            <div id="stage-clear-screen" class="overlay-screen">
                <div id="stage-clear-panel" class="overlay-panel">
                    <h1 id="stage-clear-title" class="overlay-title">STAGE CLEAR!</h1>
                    <button id="next-stage-button" class="overlay-button">PROSSEGUIR</button>
                </div>
            </div>
            
            <div id="pause-screen" class="overlay-screen">
                <div id="pause-panel" class="overlay-panel">
                    <h1 id="pause-title" class="overlay-title">PAUSADO</h1>
                    <div class="menu-buttons">
                        <button id="resume-button" class="overlay-button">RETOMAR</button>
                        <button id="settings-button-pause" class="overlay-button">CONFIGURAÇÕES</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Variáveis Globais do Jogo ---
        let player, playerBullets, enemies, meteors, enemyBullets, bossBullets, powerUps, stars;
        let score = 0;
        let playerHealth = 100, playerMaxHealth = 100, playerDamage = 1;
        let extraShots = 0;
        const MAX_EXTRA_SHOTS = 2;
        let shieldAmount = 0, shieldDuration = 30;
        const SHIELD_MAX_DURATION = 30, SHIELD_MAX_VALUE = 100;
        let shieldTimerEvent;

        let baseEnemyLevel = 1, currentStage = 1, scoreToNextBoss = 100;
        let bossFightActive = false, bossObject = null;
        
        let enemySpawnTimer, meteorSpawnTimer;

        let performanceMode = false;
        let musicEnabled = true;
        let sfxEnabled = true;
        let settingsReturnTo = 'start'; // 'start' or 'pause'

        let lightPool = [];
        const MAX_LIGHTS = 50;
        let explosionEmitter;

        // NOVO: Variáveis de áudio
        let playerShootSynth, explosionSynth, backgroundMusic;

        const PLAYER_SPRITE_WIDTH = 120, PLAYER_SPRITE_HEIGHT = 120;
        const ENEMY_SPRITE_WIDTH = 120, ENEMY_SPRITE_HEIGHT = 120;
        const BOSS_SPRITE_WIDTH = 240, BOSS_SPRITE_HEIGHT = 240;
        const BULLET_SPRITE_WIDTH = 32, BULLET_SPRITE_HEIGHT = 32;
        const POWERUP_SPRITE_SIZE = 24;

        let scoreTextElement, baseEnemyLevelUITextElement, healthBarFillElement, 
            healthTextElement, shieldBarOverlayElement, shieldTimerElement, 
            damageTextElement, extraShotsTextElement, stageTextElement,
            bossHealthContainerElement, bossHealthBarFillElement;
        
        let isPaused = false;
        let isGameStarted = false;

        // --- Lógica de Configurações e Detecção ---

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function applyPerformanceSettings() {
            const uiElementsWithBlur = document.querySelectorAll('.info-panel, .progress-bar-background, .stat-item, #shield-timer-container, .overlay-screen .overlay-panel');
            if (performanceMode) {
                uiElementsWithBlur.forEach(el => el.classList.remove('blur-effect'));
            } else {
                uiElementsWithBlur.forEach(el => el.classList.add('blur-effect'));
            }
        }

        function loadSettings() {
            performanceMode = JSON.parse(localStorage.getItem('spaceShooterPerformanceMode')) ?? isMobileDevice();
            musicEnabled = JSON.parse(localStorage.getItem('spaceShooterMusicEnabled')) ?? true;
            sfxEnabled = JSON.parse(localStorage.getItem('spaceShooterSfxEnabled')) ?? true;

            document.getElementById('performance-toggle').checked = performanceMode;
            document.getElementById('music-toggle').checked = musicEnabled;
            document.getElementById('sfx-toggle').checked = sfxEnabled;
            
            applyPerformanceSettings();
        }

        // --- Configuração do Phaser ---
        
        let game;
        
        function initializeGame() {
            const config = {
                type: performanceMode ? Phaser.CANVAS : Phaser.AUTO,
                width: 450,
                height: 800,
                parent: 'game-container',
                backgroundColor: '#061021',
                scale: {
                    mode: Phaser.Scale.FIT,
                    autoCenter: Phaser.Scale.CENTER_BOTH
                },
                physics: {
                    default: 'arcade',
                    arcade: {
                        gravity: { y: 0 },
                        debug: false 
                    }
                },
                scene: {
                    preload: preload,
                    create: create,
                    update: update
                }
            };
            game = new Phaser.Game(config);
        }

        function resizeGameContainer() {
            const container = document.getElementById('game-container');
            container.style.height = `${window.innerHeight}px`;
        }

        window.addEventListener('resize', resizeGameContainer);
        resizeGameContainer();

        // --- Funções Principais do Phaser ---

        function preload() {
            this.load.image('player_sprite', 'player1.png');
            this.load.image('enemy1_sprite', 'enemy1.png');
            this.load.image('boss_sprite', 'boss.png'); 
            this.load.image('player_bullet_sprite', 'player_bullet.png');
            this.load.image('enemy_bullet_sprite', 'enemy_bullet.png'); 
            this.load.image('powerup_damage', 'Damage_Bonus.png');
            this.load.image('powerup_health', 'HP_Bonus.png');
            this.load.image('powerup_extraShot', 'Rockets_Bonus.png');
            this.load.image('powerup_shield', 'Armor_Bonus.png');
            this.load.atlas('flares', 'https://labs.phaser.io/assets/particles/flares.png', 'https://labs.phaser.io/assets/particles/flares.json');
            
            for (let i = 1; i <= 10; i++) {
                const num = i < 10 ? `0${i}` : i;
                this.load.image(`Meteor_${num}`, `Meteor_${num}.png`);
            }
        }

        function create() {
            setupAudio(); // NOVO: Inicializa os sons
            setupVisuals.call(this);
            setupPlayer.call(this);
            setupGroups.call(this);
            setupUI.call(this);
            setupTimers.call(this);
            setupInput.call(this);
            setupCollisions.call(this);

            const uiContainer = document.getElementById('game-ui');
            const canvas = this.sys.game.canvas;

            const updateUiPosition = () => {
                setTimeout(() => {
                    const bounds = canvas.getBoundingClientRect();
                    if (bounds.width > 0 && bounds.height > 0) {
                        uiContainer.style.top = `${bounds.top}px`;
                        uiContainer.style.left = `${bounds.left}px`;
                        uiContainer.style.width = `${bounds.width}px`;
                        uiContainer.style.height = `${bounds.height}px`;
                    }
                }, 50); 
            };
            
            const fullResize = () => {
                resizeGameContainer();
                updateUiPosition();
            }

            fullResize();
            this.scale.on('resize', fullResize);
            document.addEventListener('fullscreenchange', fullResize);

            this.physics.pause();
            this.time.paused = true;
        }

        function update() {
            if (!isGameStarted || !player.active || isPaused) return;

            stars.children.each(star => {
                if (star && star.y > game.config.height + 10) star.destroy();
            });
            
            if (player.shieldSprite) player.shieldSprite.setPosition(player.x, player.y);

            if (!bossFightActive && score >= scoreToNextBoss) {
                 startBossFight.call(this);
            }
        }
        
        // --- Funções de Setup ---
        
        // NOVO: Função para criar os sintetizadores de áudio
        function setupAudio() {
            playerShootSynth = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 },
                volume: -15
            }).toDestination();

            explosionSynth = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.005, decay: 0.2, sustain: 0 },
                volume: -10
            }).toDestination();

            const musicSynth = new Tone.FMSynth({
                harmonicity: 1.5,
                modulationIndex: 10,
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 },
                modulationEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.1 }
            }).toDestination();
            musicSynth.volume.value = -25;

            const notes = ['C2', 'G2', 'Eb3', 'G2', 'C3', 'G2', 'F#2', 'G2'];
            backgroundMusic = new Tone.Sequence((time, note) => {
                musicSynth.triggerAttackRelease(note, '8n', time);
            }, notes, '4n').start(0);
            Tone.Transport.bpm.value = 90;
        }

        function setupVisuals() {
            const interFont = document.createElement('link');
            interFont.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap';
            interFont.rel = 'stylesheet';
            document.head.appendChild(interFont);
            
            const graphics = this.add.graphics();
            graphics.fillStyle(0xffffff, 1);
            graphics.fillCircle(2, 2, 2);
            graphics.generateTexture('star_particle', 4, 4);
            graphics.fillStyle(0x00aeff, 0.5);
            graphics.fillCircle(48, 48, 48);
            graphics.generateTexture('shield_glow_particle', 96, 96);
            graphics.destroy();

            if (!performanceMode) {
                this.lights.enable();
                this.lights.setAmbientColor(0x606060); 
                for (let i = 0; i < MAX_LIGHTS; i++) {
                    const light = this.lights.addLight(0, 0, 100, 0xffffff, 0).setVisible(false);
                    lightPool.push(light);
                }
            }

            stars = this.physics.add.group();

            explosionEmitter = this.add.particles(0, 0, 'flares', {
                frame: [ 'yellow', 'orange' ],
                lifespan: 1000,
                speed: { min: 100, max: 300 },
                scale: { start: 0.5, end: 0 },
                gravityY: 500,
                blendMode: 'ADD',
                emitting: false
            });
        }

        function setupPlayer() {
            player = this.add.sprite(game.config.width / 2, game.config.height - 100, 'player_sprite');
            player.shieldSprite = this.add.sprite(player.x, player.y, 'shield_glow_particle')
                .setBlendMode('ADD')
                .setDepth(player.depth - 1)
                .setVisible(false);

            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);
            
            const playerHitboxWidth = PLAYER_SPRITE_WIDTH * 0.70;
            const playerHitboxHeight = PLAYER_SPRITE_HEIGHT * 0.97;
            player.body.setSize(playerHitboxWidth, playerHitboxHeight)
                .setOffset((PLAYER_SPRITE_WIDTH - playerHitboxWidth) / 1.7, (PLAYER_SPRITE_HEIGHT - playerHitboxHeight) / 2);

            if (!performanceMode) {
                player.setPipeline('Light2D');
            }
        }

        function setupGroups() {
            playerBullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 30 });
            enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });
            meteors = this.physics.add.group({ classType: Meteor, runChildUpdate: true });
            enemyBullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 100 });
            bossBullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 100 });
            powerUps = this.physics.add.group({ classType: PowerUp, runChildUpdate: true });
        }

        function setupUI() {
            const ids = ['score-value', 'level-value', 'stage-value', 'health-bar-fill', 'health-bar-text', 'shield-bar-overlay', 'shield-timer', 'damage-value', 'cannons-value', 'boss-health-container', 'boss-health-bar-fill'];
            [scoreTextElement, baseEnemyLevelUITextElement, stageTextElement, healthBarFillElement, healthTextElement, shieldBarOverlayElement, shieldTimerElement, damageTextElement, extraShotsTextElement, bossHealthContainerElement, bossHealthBarFillElement] = ids.map(id => document.getElementById(id));
            
            document.getElementById('start-game-button').addEventListener('click', () => startGame.call(this));
            
            document.getElementById('restart-button').addEventListener('click', () => {
                updateCursorVisibility(false);
                document.getElementById('game-over-screen').style.opacity = '0';
                document.getElementById('game-over-screen').style.visibility = 'hidden';
                if (musicEnabled) Tone.Transport.stop();
                resetGameVariables();
                this.scene.restart();
            });
            
            document.getElementById('next-stage-button').addEventListener('click', () => startNextStage.call(this));
            document.getElementById('resume-button').addEventListener('click', () => togglePause.call(this));
            document.getElementById('pause-button').addEventListener('click', () => togglePause.call(this));
            
            document.getElementById('fullscreen-button').addEventListener('click', toggleApiFullscreen);
            document.addEventListener('fullscreenchange', updateFullscreenButton);

            updateUI(); 
        }

        function setupTimers() {
            this.time.addEvent({ delay: performanceMode ? 100 : 50, callback: spawnStar, callbackScope: this, loop: true });
            this.time.addEvent({ delay: 400, callback: firePlayerBullet, callbackScope: this, loop: true });
            enemySpawnTimer = this.time.addEvent({ delay: 2700, callback: spawnEnemy, callbackScope: this, loop: true });
            meteorSpawnTimer = this.time.addEvent({ delay: 6338, callback: spawnMeteor, callbackScope: this, loop: true });
        }

        function setupInput() {
            this.input.on('pointermove', (pointer) => {
                if (this.sys.game.device.input.touch && !pointer.isDown) return;
                if(player.active) {
                    this.tweens.add({
                        targets: player,
                        x: pointer.x,
                        y: pointer.y,
                        duration: 100,
                        ease: 'Sine.easeOut'
                    });
                }
            }, this);
            this.input.keyboard.on('keydown-SPACE', () => togglePause.call(this));
        }

        function setupCollisions() {
            this.physics.add.overlap(playerBullets, meteors, handlePlayerHit, null, this);
            this.physics.add.overlap(playerBullets, enemies, handlePlayerHit, null, this);
            
            this.physics.add.overlap(player, meteors, hitPlayerByMeteor, null, this);
            this.physics.add.overlap(player, enemyBullets, (p, b) => hitPlayer(p, b, this), null, this);
            this.physics.add.overlap(player, bossBullets, (p, b) => hitPlayer(p, b, this), null, this);
            this.physics.add.overlap(player, enemies, (p, e) => hitPlayerByEnemy(p, e, this), null, this);
            this.physics.add.overlap(player, powerUps, collectPowerUp, null, this);
        }

        // --- Classes do Jogo (com lógica de performance) ---

        class Bullet extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, null);
                this.type = ''; this.damage = 0; this.light = null; this.bounces = 0; this.justBounced = false;
            }

            fire(x, y, vx, vy, type, damage, bounces = 0) {
                Object.assign(this, { type, damage, bounces });
                this.setTexture(type === 'playerBullet' ? 'player_bullet_sprite' : 'enemy_bullet_sprite');
                this.enableBody(true, x, y, true, true);
                
                const bulletHitboxSize = BULLET_SPRITE_WIDTH * 0.97;
                this.body.setSize(bulletHitboxSize, bulletHitboxSize).setOffset((BULLET_SPRITE_WIDTH - bulletHitboxSize) / 2, (BULLET_SPRITE_HEIGHT - bulletHitboxSize) / 2);

                this.setVelocity(vx, vy);
                
                if (bounces > 0) this.body.setCollideWorldBounds(true).setBounce(1);

                if (!performanceMode) {
                    this.setPipeline('Light2D');
                    this.light = getLightFromPool();
                    if (this.light) {
                        const color = this.type === 'playerBullet' ? 0x00ffff : 0xff8c00;
                        this.light.setPosition(x, y).setColor(color).setRadius(250).setVisible(true);
                        this.scene.tweens.add({ targets: this.light, intensity: 1.5, duration: 100, ease: 'Sine.easeIn' });
                    }
                }
            }
            
            kill() {
                if (!this.active) return;
                if (!performanceMode && this.light && this.light.visible) {
                    const lightToFade = this.light;
                    this.scene.tweens.add({
                        targets: lightToFade, intensity: 0, duration: 100, ease: 'Sine.easeOut',
                        onComplete: () => lightToFade.setVisible(false)
                    });
                    this.light = null;
                }
                this.disableBody(true, true);
            }

            preUpdate(time, delta) {
                super.preUpdate(time, delta);
                if (!this.active) return;
                if (!performanceMode && this.light) this.light.setPosition(this.x, this.y);
                
                if (this.bounces > 0) {
                    if (this.body.blocked.left || this.body.blocked.right) {
                        if (!this.justBounced) {
                            this.bounces--; this.justBounced = true;
                            this.scene.time.delayedCall(50, () => { this.justBounced = false; });
                        }
                    }
                    if (this.bounces <= 0) {
                        this.body.setCollideWorldBounds(false);
                        this.scene.time.delayedCall(1000, () => this.kill());
                    }
                } else if (this.y < -20 || this.y > game.config.height + 20 || this.x < -20 || this.x > game.config.width + 20) {
                    this.kill();
                }
            }
        }
        
        class Meteor extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, null);
                scene.add.existing(this); scene.physics.add.existing(this);
                this.body.allowGravity = false; this.setOrigin(0.5);
                this.health = 1; this.initialHealth = 1;
                this.healthBarBackground = scene.add.rectangle(0, 0, 1, 5, 0x555555).setOrigin(0.5, 0.5);
                this.healthBar = scene.add.rectangle(0, 0, 1, 5, 0xcccccc).setOrigin(0.5, 0.5);
            }

            spawn(x, y) {
                const meteorType = Phaser.Math.Between(1, 10);
                const num = meteorType < 10 ? `0${meteorType}` : meteorType;
                this.setTexture(`Meteor_${num}`);

                this.setScale(Phaser.Math.FloatBetween(0.8, 1.2) * 0.27);
                
                const baseHealth = Phaser.Math.Between(7, 13);
                this.health = Math.ceil(baseHealth * (1 + baseEnemyLevel * 0.2));
                this.initialHealth = this.health;

                this.enableBody(true, x, y, true, true);
                this.body.setSize(this.width * 0.97, this.height * 0.97);

                this.setVelocityY(Phaser.Math.Between(80, 150)).setAngularVelocity(Phaser.Math.Between(-50, 50));
                if (!performanceMode) {
                    this.setPipeline('Light2D');
                }

                this.healthBarBackground.setVisible(true); this.healthBar.setVisible(true);
                this.updateHealthBar();
            }

            takeDamage(amount) {
                this.health -= amount;
                this.updateHealthBar();
                if (this.health <= 0) this.kill();
            }

            kill() {
                if (!this.active) return;
                if (sfxEnabled) explosionSynth.triggerAttackRelease("8n");
                this.healthBarBackground.setVisible(false); this.healthBar.setVisible(false);
                if (!performanceMode) createExplosionLight(this.x, this.y, this.scene);
                if (explosionEmitter) explosionEmitter.explode(performanceMode ? 8 : 15, this.x, this.y);
                this.dropPowerUp();
                this.disableBody(true, true);
            }
            
            dropPowerUp() {
                if (Math.random() < 0.25) {
                    let type = bossFightActive ? (Math.random() < 0.5 ? 'health' : 'shield') : ['damage', 'health', 'extraShot', 'shield'][Phaser.Math.Between(0,3)];
                    const powerUp = powerUps.get(this.x, this.y);
                    if (powerUp) powerUp.spawn(this.x, this.y, type);
                }
            }

            updateHealthBar() {
                const barWidth = this.displayWidth * 0.8;
                const barHeight = 5;
                const yOffset = this.displayHeight / 2 + 10;
                this.healthBarBackground.setPosition(this.x, this.y + yOffset).setSize(barWidth, barHeight);
                const healthRatio = this.health / this.initialHealth;
                this.healthBar.setPosition(this.x - (barWidth * (1 - healthRatio) / 2), this.y + yOffset).setSize(barWidth * healthRatio, barHeight);
            }

            preUpdate(time, delta) {
                super.preUpdate(time, delta);
                if(this.active) {
                    this.updateHealthBar();
                    if (this.y > game.config.height + this.displayHeight) this.kill();
                }
            }
        }

        class Enemy extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, null);
                scene.add.existing(this); scene.physics.add.existing(this);
                this.body.allowGravity = false; this.setOrigin(0.5);
                this.health = 1; this.initialHealth = 1; this.speed = 100; this.isBoss = false; this.isEnraged = false;
                this.level = 1; this.damage = 1;
                this.fireTimer = scene.time.addEvent({ delay: 1, callback: this.fireBullet, callbackScope: this, loop: true, paused: true });
                this.healthBarBackground = scene.add.rectangle(0, 0, 1, 5, 0x555555).setOrigin(0.5, 0.5);
                this.healthBar = scene.add.rectangle(0, 0, 1, 5, 0xff4500).setOrigin(0.5, 0.5);
                this.levelText = scene.add.text(0, 0, '', { fontSize: '10px', fill: '#fff', fontFamily: 'Inter' }).setOrigin(0.5).setDepth(1);
                this.horizontalTween = null; this.verticalTween = null;
            }

            spawn(x, y, isBoss = false, level = 1) {
                this.enableBody(true, x, y, true, true);
                this.level = level;
                if (this.horizontalTween) this.horizontalTween.stop();
                if (this.verticalTween) this.verticalTween.stop();
                if (!performanceMode) {
                    this.setPipeline('Light2D');
                }
                
                this.isBoss = isBoss;
                if (isBoss) this.spawnAsBoss(x, y);
                else this.spawnAsMinion(x, y, level);
                
                this.setVisible(true).setActive(true);
                this.levelText.setVisible(!isBoss);
                this.fireTimer.paused = false;
                this.updateHealthBar();
            }

            spawnAsMinion(x, y, level) {
                this.setTexture('enemy1_sprite');
                
                const baseHealth = 3;
                this.health = Math.ceil(baseHealth * (1 + level * 0.2));
                this.initialHealth = this.health;
                this.damage = 5 + (level - 1);

                const baseEnemySpeed = 100;
                const levelSpeedIncreaseFactor = Math.min((level - 1) * 0.05, 0.8);
                this.speed = baseEnemySpeed * (1 + levelSpeedIncreaseFactor);
                this.setVelocityY(this.speed);
                
                const enemyHitboxWidth = ENEMY_SPRITE_WIDTH * 0.70;
                const enemyHitboxHeight = ENEMY_SPRITE_HEIGHT * 0.97;
                this.body.setSize(enemyHitboxWidth, enemyHitboxHeight).setOffset((ENEMY_SPRITE_WIDTH - enemyHitboxWidth) / 1.7, (ENEMY_SPRITE_HEIGHT - enemyHitboxHeight) / 2);

                this.fireTimer.delay = 2700 - (level * 20);
                this.fireTimer.callback = this.fireBullet;

                let tintColor = 0xFFFFFF;
                if (level >= 2) tintColor = 0xADD8E6; if (level >= 4) tintColor = 0x90EE90;
                if (level >= 6) tintColor = 0xFFD700; if (level >= 8) tintColor = 0xFFA500;
                if (level >= 10) tintColor = 0xFF4500; if (level >= 15) tintColor = 0xDA70D6;
                if (level >= 20) tintColor = 0xFF0000;
                this.setTint(tintColor);
                this.levelText.setText(`Lv${level}`);
                this.healthBar.setVisible(true); this.healthBarBackground.setVisible(true);
            }

            spawnAsBoss(x, y) {
                this.setTexture('boss_sprite');
                this.setScale(0.3).setAlpha(1).setAngle(180).setDepth(10);
                
                const healthMultiplier = Math.pow(1.3, currentStage - 1);
                const damageMultiplier = Math.pow(1.3, currentStage - 1);
                const speedMultiplier = Math.pow(1.05, currentStage - 1);

                this.health = 600 * healthMultiplier;
                this.initialHealth = this.health;
                this.damage = 15 * damageMultiplier;
                this.isEnraged = false;

                const bossHitboxWidth = this.width * 0.8;
                const bossHitboxHeight = this.height * 0.8;
                this.body.setSize(bossHitboxWidth, bossHitboxHeight).setOffset((this.width - bossHitboxWidth) / 2, (this.height - bossHitboxHeight) / 2);

                this.fireTimer.delay = 1500;
                this.fireTimer.callback = this.fireBossPattern;

                this.scene.tweens.add({
                    targets: this, y: 150, duration: 2000, ease: 'Cubic.easeOut',
                    onComplete: () => {
                        this.horizontalTween = this.scene.tweens.add({ targets: this, x: { from: 80, to: game.config.width - 80 }, ease: 'Sine.easeInOut', duration: 3000 / speedMultiplier, repeat: -1, yoyo: true });
                        this.verticalTween = this.scene.tweens.add({ targets: this, y: { from: 120, to: 220 }, ease: 'Sine.easeInOut', duration: 1875 / speedMultiplier, repeat: -1, yoyo: true });
                    }
                });

                this.healthBar.setVisible(false); this.healthBarBackground.setVisible(false);
            }

            fireBullet() {
                if (!this.active) return;
                const bullet = enemyBullets.get();
                if (bullet) bullet.fire(this.x, this.y + this.displayHeight / 2 + 10, 0, this.speed * 2.5, 'enemyBullet', this.damage);
            }

            fireBossPattern() {
                if (!this.active || !player.active) return;
                const pattern = Phaser.Math.Between(1, 3);
                switch(pattern) {
                    case 1: this.fireStraightShot(); break;
                    case 2: this.fireSpreadShot(); break;
                    case 3: this.fireRicochetShot(); break;
                }
            }

            fireStraightShot() {
                const angle = Phaser.Math.Angle.Between(this.x, this.y, player.x, player.y);
                const vx = Math.cos(angle) * 300;
                const vy = Math.sin(angle) * 300;
                const bullet = bossBullets.get();
                if (bullet) bullet.fire(this.x, this.y, vx, vy, 'enemyBullet', this.damage);
            }

            fireSpreadShot() {
                const shots = this.isEnraged ? 12 : 8;
                for (let i = 0; i < shots; i++) {
                    const angle = Phaser.Math.DegToRad((360 / shots) * i);
                    const vx = Math.cos(angle) * 250;
                    const vy = Math.sin(angle) * 250;
                    const bullet = bossBullets.get();
                    if (bullet) bullet.fire(this.x, this.y, vx, vy, 'enemyBullet', this.damage);
                }
            }

            fireRicochetShot() {
                const bullet = bossBullets.get();
                if (bullet) {
                    const vx = Phaser.Math.Between(1,2) === 1 ? -200 : 200;
                    bullet.fire(this.x, this.y, vx, 200, 'enemyBullet', this.damage, 2);
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                this.updateHealthBar();
                
                this.setTint(0xff0000);
                this.scene.time.delayedCall(100, () => {
                    if (this.active) {
                       this.clearTint();
                       if (this.isEnraged) this.setTint(0xff6666);
                    }
                });

                if (this.health <= 0) {
                    this.kill();
                } else if (this.isBoss && !this.isEnraged && (this.health / this.initialHealth) <= 0.35) {
                    this.enrage();
                }
            }

            enrage() {
                this.isEnraged = true;
                this.setTint(0xff6666);
                if (this.horizontalTween) this.horizontalTween.timeScale *= 1.35;
                if (this.verticalTween) this.verticalTween.timeScale *= 1.35;
                this.fireTimer.delay = 1000;
                this.damage *= 1.35;

                let rageText = this.scene.add.text(this.x, this.y - 50, 'ENRAGED!', { fontSize: '24px', fill: '#ff0000', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);
                this.scene.tweens.add({
                    targets: rageText, alpha: 0, y: '-=50', duration: 1500,
                    onComplete: () => rageText.destroy()
                });
            }
            
            kill() {
                if (!this.active) return;
                if (sfxEnabled) explosionSynth.triggerAttackRelease("8n");
                this.setActive(false);
                if (!performanceMode) createExplosionLight(this.x, this.y, this.scene);
                this.fireTimer.paused = true;
                this.healthBarBackground.setVisible(false); this.healthBar.setVisible(false); this.levelText.setVisible(false);
                if (this.horizontalTween) this.horizontalTween.stop();
                if (this.verticalTween) this.verticalTween.stop();
                if (explosionEmitter) explosionEmitter.explode(performanceMode ? 15 : (this.isBoss ? 100 : 30), this.x, this.y);
                
                if (!this.isBoss) {
                    score += this.level;
                    updateUI();
                    this.dropPowerUp();
                } else {
                    score += 50 * currentStage;
                    bossObject = null;
                    bossFightActive = false;
                    this.scene.time.delayedCall(2000, () => endBossFight.call(this.scene));
                }
                
                this.disableBody(true, true);
            }

            dropPowerUp() {
                if (Math.random() < 0.1) {
                    const type = ['damage', 'health', 'extraShot', 'shield'][Phaser.Math.Between(0,3)];
                    const powerUp = powerUps.get(this.x, this.y);
                    if (powerUp) powerUp.spawn(this.x, this.y, type);
                }
            }

            updateHealthBar() {
                const healthRatio = this.health / this.initialHealth;
                if (this.isBoss) {
                    if(bossHealthBarFillElement) bossHealthBarFillElement.style.width = `${healthRatio * 100}%`;
                } else {
                    const barWidth = this.displayWidth * 0.6;
                    const yOffset = this.y - this.displayHeight / 2 - 15;
                    const xOffset = this.x;

                    this.healthBarBackground.setPosition(xOffset, yOffset).setSize(barWidth, 5).setOrigin(0.5, 0.5);
                    this.healthBar.setPosition(xOffset - (barWidth * (1 - healthRatio) / 2), yOffset).setSize(barWidth * healthRatio, 5).setOrigin(0.5, 0.5);
                    this.healthBar.setFillStyle(0x00ff00);
                }
            }

            preUpdate(time, delta) {
                super.preUpdate(time, delta);
                if (this.active && !this.isBoss) {
                    this.updateHealthBar();
                    this.levelText.setPosition(this.x, this.y - this.displayHeight / 2 - 35);
                    if (this.y > game.config.height + 50) this.kill();
                }
            }
        }

        class PowerUp extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, null);
                scene.add.existing(this); scene.physics.add.existing(this);
                this.body.allowGravity = false; this.setOrigin(0.5); this.type = '';
            }

            spawn(x, y, type) {
                this.enableBody(true, x, y, true, true);
                this.type = type;
                this.setTexture('powerup_' + type);
                this.setVelocityY(100);
                if (!performanceMode) {
                    this.setPipeline('Light2D');
                }
                this.body.setSize(POWERUP_SPRITE_SIZE, POWERUP_SPRITE_SIZE);
            }

            preUpdate(time, delta) {
                super.preUpdate(time, delta);
                if (this.y > game.config.height + 50) this.disableBody(true, true);
            }
        }

        // --- Funções de Lógica do Jogo ---

        function startGame() {
            const scene = game.scene.scenes[0];
            if (!scene) return; 

            // Inicia o contexto de áudio
            Tone.start();
            if (musicEnabled) {
                Tone.Transport.start();
            }

            updateCursorVisibility(false);
            const startScreen = document.getElementById('start-screen');
            startScreen.style.opacity = '0';
            startScreen.style.visibility = 'hidden';

            isGameStarted = true;
            scene.physics.resume();
            scene.time.paused = false;

            toggleApiFullscreen(true);
        }

        function firePlayerBullet() {
            if (!player.active) return;
            if (sfxEnabled) playerShootSynth.triggerAttackRelease("C5", "16n");
            const baseVy = -400;
            const bulletSpawnY = player.y - player.displayHeight / 2;
            let bullet = playerBullets.get();
            if (bullet) bullet.fire(player.x, bulletSpawnY, 0, baseVy, 'playerBullet', playerDamage);
            const offset = 20;
            if (extraShots >= 1) {
                let bulletLeft = playerBullets.get();
                if (bulletLeft) bulletLeft.fire(player.x - offset, bulletSpawnY, 0, baseVy, 'playerBullet', playerDamage);
            }
            if (extraShots >= 2) {
                let bulletRight = playerBullets.get();
                if (bulletRight) bulletRight.fire(player.x + offset, bulletSpawnY, 0, baseVy, 'playerBullet', playerDamage);
            }
        }

        function spawnStar() {
            if (!isGameStarted) return;
            const x = Phaser.Math.Between(0, game.config.width);
            const star = stars.create(x, -10, 'star_particle');
            if (star) {
                star.setVelocityY(Phaser.Math.Between(50, 200)).setScale(Phaser.Math.FloatBetween(0.2, 1)).setAlpha(star.scale * 0.8);
            }
        }

        function spawnEnemy() {
            if (bossFightActive) return;
            const x = Phaser.Math.Between(50, game.config.width - 50);
            const enemyLevelToSpawn = (baseEnemyLevel <= 3) ? baseEnemyLevel : Phaser.Math.Between(baseEnemyLevel - 2, baseEnemyLevel);
            const enemy = enemies.get();
            if (enemy) enemy.spawn(x, -50, false, enemyLevelToSpawn);
        }
        
        function spawnMeteor() {
            const x = Phaser.Math.Between(50, game.config.width - 50);
            const meteor = meteors.get();
            if (meteor) meteor.spawn(x, -100);
        }

        function startBossFight() {
            bossFightActive = true;
            enemySpawnTimer.paused = true;
            
            enemies.children.each(e => { if(e.active) e.kill(); });

            if(bossHealthContainerElement) bossHealthContainerElement.style.display = 'flex';

            let warningText = this.add.text(game.config.width/2, game.config.height/2, 'WARNING!', { fontSize: '60px', fill: '#ff0000', fontStyle: 'bold', stroke: '#000', strokeThickness: 8 }).setOrigin(0.5).setDepth(200).setAlpha(0);
            this.tweens.add({
                targets: warningText, alpha: 1, scale: {from: 2, to: 1}, duration: 500, yoyo: true, hold: 1500,
                onComplete: () => {
                    warningText.destroy();
                    bossObject = enemies.get();
                    if (bossObject) bossObject.spawn(game.config.width / 2, -100, true);
                }
            });
        }

        function endBossFight() {
            updateCursorVisibility(true);
            this.physics.pause();
            meteorSpawnTimer.paused = true;
            
            if(bossHealthContainerElement) bossHealthContainerElement.style.display = 'none';

            const screen = document.getElementById('stage-clear-screen');
            screen.style.visibility = 'visible';
            screen.style.opacity = '1';
        }

        function startNextStage() {
            updateCursorVisibility(false);
            const screen = document.getElementById('stage-clear-screen');
            screen.style.visibility = 'hidden';
            screen.style.opacity = '0';

            this.physics.resume();
            meteorSpawnTimer.paused = false;
            enemySpawnTimer.paused = false;

            currentStage++;
            scoreToNextBoss = Math.ceil(scoreToNextBoss * 1.40);
            
            playerDamage = baseEnemyLevel;

            updateUI();
        }
        
        function handlePlayerHit(bullet, target) {
            if (!bullet.active || !target.active) return;

            bullet.kill();

            let damageDealt = bullet.damage;
            const isCritical = Math.random() < 0.25;

            if (isCritical) {
                damageDealt *= 1.5;
                
                const critText = this.add.text(target.x, target.y, 'CRIT!', {
                    fontFamily: 'Inter', fontSize: '18px', fill: '#ffc700',
                    stroke: '#000000', strokeThickness: 4, fontStyle: 'bold'
                }).setOrigin(0.5).setDepth(200);
                
                const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
                const distance = 40;
                const targetX = target.x + Math.cos(angle) * distance;
                const targetY = target.y + Math.sin(angle) * distance;

                this.tweens.add({
                    targets: critText, x: targetX, y: targetY, alpha: 0, scale: 1.5, duration: 600, ease: 'Power3',
                    onComplete: () => critText.destroy()
                });
            }

            target.takeDamage(damageDealt);
        }

        function hitPlayerByMeteor(player, meteor) {
            applyDamageToPlayer(30, this);
            meteor.kill();
        }

        function hitPlayer(player, bullet, scene) {
            bullet.kill();
            applyDamageToPlayer(bullet.damage, scene);
        }

        function hitPlayerByEnemy(player, enemy, scene) {
            applyDamageToPlayer(enemy.damage, scene);
            enemy.kill();
        }

        function applyDamageToPlayer(damage, scene) {
            if (!player.active) return;
            
            scene.cameras.main.shake(100, 0.01);
            player.setTint(0xff0000);
            scene.time.delayedCall(100, () => player.clearTint());

            if (shieldAmount > 0) {
                shieldAmount -= damage;
                if (shieldAmount < 0) { playerHealth += shieldAmount; shieldAmount = 0; }
            } else {
                playerHealth -= damage;
            }

            if (playerHealth <= 0) { playerHealth = 0; gameOver.call(scene); }
            updateUI();
        }

        function collectPowerUp(player, powerUp) {
            powerUp.disableBody(true, true);
            switch (powerUp.type) {
                case 'damage': playerDamage++; break;
                case 'health': playerHealth = Math.min(playerMaxHealth, playerHealth + 20); break;
                case 'extraShot': if (extraShots < MAX_EXTRA_SHOTS) extraShots++; else score += 10; break;
                case 'shield':
                    shieldAmount = SHIELD_MAX_VALUE;
                    shieldDuration = SHIELD_MAX_DURATION;
                    if (shieldTimerEvent) shieldTimerEvent.destroy();
                    shieldTimerEvent = this.time.addEvent({ delay: 1000, callback: updateShieldDuration, callbackScope: this, loop: true });
                    player.shieldSprite.setVisible(true);
                    this.tweens.add({ targets: player.shieldSprite, alpha: { from: 0.7, to: 0.3 }, scale: { from: 1.2, to: 1.3 }, ease: 'Sine.easeInOut', duration: 500, yoyo: true, repeat: -1 });
                    break;
            }
            updateUI();
        }

        function updateShieldDuration() {
            if (shieldAmount > 0) {
                shieldDuration--;
                if (shieldDuration <= 0) {
                    shieldAmount = 0;
                    if (shieldTimerEvent) shieldTimerEvent.destroy();
                    this.tweens.killTweensOf(player.shieldSprite);
                    player.shieldSprite.setVisible(false);
                }
            }
            updateUI();
        }

        function updateUI() {
            if (scoreTextElement) scoreTextElement.textContent = score;
            
            let newBaseEnemyLevel = Math.floor(score / 50) + 1;
            if (newBaseEnemyLevel > baseEnemyLevel) baseEnemyLevel = newBaseEnemyLevel;
            if (baseEnemyLevelUITextElement) baseEnemyLevelUITextElement.textContent = baseEnemyLevel;
            if (stageTextElement) stageTextElement.textContent = currentStage;
            
            if (healthBarFillElement) {
                healthBarFillElement.style.width = `${(playerHealth / playerMaxHealth) * 100}%`;
                healthTextElement.textContent = `${Math.ceil(playerHealth)} / ${playerMaxHealth}`;
            }
            
            if (shieldBarOverlayElement) {
                if (shieldAmount > 0) {
                    shieldBarOverlayElement.style.opacity = '1';
                    shieldBarOverlayElement.style.width = `${(shieldAmount / SHIELD_MAX_VALUE) * 100}%`;
                    shieldTimerElement.style.opacity = '1';
                    shieldTimerElement.textContent = `${shieldDuration}s`;
                    document.getElementById('shield-timer-icon').style.opacity = '1';
                } else {
                    shieldBarOverlayElement.style.opacity = '0';
                    shieldTimerElement.style.opacity = '0';
                    document.getElementById('shield-timer-icon').style.opacity = '0.5';
                }
            }
            
            if (damageTextElement) damageTextElement.textContent = playerDamage;
            if (extraShotsTextElement) extraShotsTextElement.textContent = 1 + extraShots;
        }

        function gameOver() {
            if (!player.active) return;
            if (musicEnabled) Tone.Transport.stop();
            updateCursorVisibility(true);
            player.setActive(false);
            this.physics.pause();
            this.time.pause();
            if (!performanceMode) createExplosionLight(player.x, player.y, this);
            if (explosionEmitter) explosionEmitter.explode(performanceMode ? 25 : 50, player.x, player.y);
            if(player.shieldSprite) player.shieldSprite.setVisible(false);
            
            if(bossHealthContainerElement) bossHealthContainerElement.style.display = 'none';
            
            const gameOverScreen = document.getElementById('game-over-screen');
            document.getElementById('final-score-value').textContent = score;
            gameOverScreen.style.visibility = 'visible';
            gameOverScreen.style.opacity = '1';

            updateRanking(score);
        }

        function resetGameVariables() {
            score = 0; playerHealth = 100; playerDamage = 1; extraShots = 0;
            shieldAmount = 0; shieldDuration = SHIELD_MAX_DURATION;
            if (shieldTimerEvent) shieldTimerEvent.destroy();
            shieldTimerEvent = null;

            bossFightActive = false; bossObject = null;
            currentStage = 1; baseEnemyLevel = 1; scoreToNextBoss = 100;
            isPaused = false;
            isGameStarted = false; 
            
            if(bossHealthContainerElement) bossHealthContainerElement.style.display = 'none';
        }
        
        // --- Funções de Controle ---

        function togglePause() {
            if (!isGameStarted) return; 
            isPaused = !isPaused;
            updateCursorVisibility(isPaused);
            const pauseScreen = document.getElementById('pause-screen');
            if (isPaused) {
                if (musicEnabled) Tone.Transport.pause();
                this.scene.pause();
                this.time.paused = true;
                pauseScreen.style.visibility = 'visible';
                pauseScreen.style.opacity = '1';
            } else {
                if (musicEnabled) Tone.Transport.start();
                this.scene.resume();
                this.time.paused = false;
                pauseScreen.style.visibility = 'hidden';
                pauseScreen.style.opacity = '0';
            }
        }
        
        // --- Funções de Ranking ---
        function getRanking() {
            const rankingJSON = localStorage.getItem('spaceShooterRanking');
            return rankingJSON ? JSON.parse(rankingJSON) : [];
        }

        function updateRanking(newScore) {
            let ranking = getRanking();
            const lowestScore = ranking.length < 5 ? 0 : ranking[4].score;

            if (newScore > lowestScore) {
                const name = prompt("Novo Recorde! Digite seu nome (3 caracteres):", "JOG");
                if (name) {
                    ranking.push({ name: name.substring(0, 3).toUpperCase(), score: newScore });
                    ranking.sort((a, b) => b.score - a.score);
                    ranking = ranking.slice(0, 5);
                    localStorage.setItem('spaceShooterRanking', JSON.stringify(ranking));
                }
            }
            displayRanking(ranking);
        }

        function displayRanking(ranking) {
            const listElement = document.getElementById('ranking-list');
            listElement.innerHTML = '';
            if (ranking.length === 0) {
                listElement.innerHTML = '<li>Nenhum recorde ainda!</li>';
            } else {
                ranking.forEach(entry => {
                    const li = document.createElement('li');
                    li.textContent = `${entry.name} - ${entry.score}`;
                    listElement.appendChild(li);
                });
            }
        }

        // --- Funções Utilitárias ---
        function getLightFromPool() {
            if (performanceMode) return null;
            return lightPool.find(light => !light.visible) || null;
        }

        function createExplosionLight(x, y, scene) {
            if (performanceMode) return;
            const light = getLightFromPool();
            if (light) {
                light.setPosition(x, y).setColor(0xffff00).setRadius(350).setVisible(true);
                scene.tweens.add({
                    targets: light, intensity: { from: 6.0, to: 0 }, duration: 250, ease: 'Cubic.easeOut',
                    onComplete: () => light.setVisible(false)
                });
            }
        }

        function updateCursorVisibility(show) {
            document.getElementById('game-container').style.cursor = show ? 'default' : 'none';
        }

        function toggleApiFullscreen(forceEnter = false) {
            const container = document.getElementById('game-container');
            const isFullscreen = !!document.fullscreenElement;

            if (!isFullscreen || forceEnter === true) {
                if (container.requestFullscreen) {
                    container.requestFullscreen().catch(err => {
                        console.error(`Erro ao tentar entrar em tela cheia: ${err.message} (${err.name})`);
                    });
                } else if (container.mozRequestFullScreen) { // Firefox
                    container.mozRequestFullScreen();
                } else if (container.webkitRequestFullscreen) { // Chrome, Safari, Opera
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) { // IE/Edge
                    container.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function updateFullscreenButton() {
            const isFullscreen = !!document.fullscreenElement;
            const enterIcon = document.getElementById('fullscreen-enter-icon');
            const exitIcon = document.getElementById('fullscreen-exit-icon');
            if (isFullscreen) {
                enterIcon.style.display = 'none';
                exitIcon.style.display = 'block';
            } else {
                enterIcon.style.display = 'block';
                exitIcon.style.display = 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            initializeGame();

            const startScreen = document.getElementById('start-screen');
            const settingsScreen = document.getElementById('settings-screen');
            const pauseScreen = document.getElementById('pause-screen');
            
            document.getElementById('settings-button-main').addEventListener('click', () => {
                settingsReturnTo = 'start';
                startScreen.style.visibility = 'hidden';
                startScreen.style.opacity = '0';
                settingsScreen.style.visibility = 'visible';
                settingsScreen.style.opacity = '1';
            });
            
            document.getElementById('settings-button-pause').addEventListener('click', () => {
                settingsReturnTo = 'pause';
                pauseScreen.style.visibility = 'hidden';
                pauseScreen.style.opacity = '0';
                settingsScreen.style.visibility = 'visible';
                settingsScreen.style.opacity = '1';
            });

            document.getElementById('back-button').addEventListener('click', () => {
                settingsScreen.style.visibility = 'hidden';
                settingsScreen.style.opacity = '0';
                if (settingsReturnTo === 'start') {
                    startScreen.style.visibility = 'visible';
                    startScreen.style.opacity = '1';
                } else {
                    pauseScreen.style.visibility = 'visible';
                    pauseScreen.style.opacity = '1';
                }
            });

            document.getElementById('performance-toggle').addEventListener('change', (event) => {
                performanceMode = event.target.checked;
                localStorage.setItem('spaceShooterPerformanceMode', JSON.stringify(performanceMode));
                applyPerformanceSettings();
            });

            document.getElementById('music-toggle').addEventListener('change', (event) => {
                musicEnabled = event.target.checked;
                localStorage.setItem('spaceShooterMusicEnabled', JSON.stringify(musicEnabled));
                if (musicEnabled && isGameStarted && !isPaused) {
                    Tone.Transport.start();
                } else {
                    Tone.Transport.pause();
                }
            });

            document.getElementById('sfx-toggle').addEventListener('change', (event) => {
                sfxEnabled = event.target.checked;
                localStorage.setItem('spaceShooterSfxEnabled', JSON.stringify(sfxEnabled));
            });
        });

    </script>
</body>
</html>
